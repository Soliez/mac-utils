#!/usr/bin/env python3

import os
import re
import sys
import pty
import json
import base64
import difflib
import argparse
import plistlib
import subprocess
from io import BytesIO
from pathlib import Path
from zipfile import ZipFile
from datetime import datetime
from urllib.parse import urlparse, quote
from typing import Literal, Optional, Union



def get_shortcut_names() -> list:
    '''
    Get the names of all shortcuts installed on the device as a list
    '''
    try:
        process = subprocess.run(['shortcuts', 'list'], capture_output=True, text=True, check=True)
        return process.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print(f"Failed to get shortcut names: {e}")
        sys.exit(1)


def get_shortcut_plist(name: str, output_dict: bool = True) -> dict|str:
    '''
    Convert the shortcut to a XML property-list and output as a dictionary or as a plist string
    
    This function uses a external utility shortcut to convert the shortcut to a plist
    Please ensure you have added this shortcut to your library

    Shortcut to Plist Non-Interactive
    https://www.icloud.com/shortcuts/b6eaf496eeae4eeeb76b4e355e83a641
    '''

    utility_shortcut = "Shortcut to Plist Non-Interactive"
    command = ['shortcuts', 'run', utility_shortcut, '-i', name, '-o', '-']
    try:
        process = subprocess.run(command, capture_output=True, check=True)
        decoded_output = base64.b64decode(process.stdout)
        if output_dict:
            return plistlib.loads(decoded_output)
        else:
            return decoded_output.decode('utf-8')
    except subprocess.CalledProcessError as e:
        print(f"Failed to run utility shortcut: {e}")
        sys.exit(1)
    except plistlib.InvalidFileException:
        print("Failed to decode plist.")
        sys.exit(1)


def save_shortcut(
        shortcut_data: dict,
        shortcut_name: str,
        save_destination: str,
        extension: str,
        valid_extensions: Literal['shortcut', 'wflow', 'plist', 'json'] = 'shortcut',
        isPlist: bool = True
        ) -> None:
    '''
    Save the converted shortcut to a file

    Acceptable values for 'extension' include:
        - shortcut
        - wflow
        - plist
        - json
    
    Note: Only files with the extension '.shortcut' or '.wflow' can be signed
    '''

    if not extension in valid_extensions:
        print(f"Error: Invalid extension '{extension}'.\nAcceptable extensions: {valid_extensions}")
        sys.exit(1)

    # expanduser is called just in case 'save_destination' contains an unexpanded tilde
    save_path = Path(save_destination).expanduser().resolve()
    
    # Create the save directory if it doesn't already exist
    save_path.mkdir(parents=True, exist_ok=True)

    save_path = save_path / shortcut_name

    if not isPlist:
        save_path = save_path.with_suffix('.json')
        save_path.write_bytes(json.dumps(shortcut_data).encode('utf-8'))
    else:
        # .shortcut and .wflow files are plists internally
        save_path = save_path.with_suffix(f'.{extension}')
        with open(str(save_path), 'wb') as f:
            plistlib.dump(shortcut_data, fp=f)
    

def get_shortcut_actions(shortcut_dict: dict) -> list[dict]:
    '''
    Extract the actions data from the shortcut dictionary
    '''
    return shortcut_dict.get('WFWorkflowActions', [])


def shortcut_exists(name: str) -> bool:
    '''
    Check whether a shortcut currently exists in your library
    '''
    return name in get_shortcut_names()


def get_action_ids(shortcut_actions: dict) -> list[str]:
    '''
    Get a list of shortcut action identifiers present in the shortcut
    '''
    return [action['WFWorkflowActionIdentifier'] for action in shortcut_actions]


def get_shortcut_uuid(shortcut_name: str) -> str | None:
    '''
    Retrieve the UUID of a shortcut by its exact name.
    '''
    try:
        process = subprocess.run(
            ['shortcuts', 'list', '--show-identifiers'],
            capture_output=True,
            text=True,
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return None
    
    pattern = re.compile(rf'^{re.escape(shortcut_name)}\s+\(([A-Za-z0-9\-]+)\)$')

    for line in process.stdout.splitlines():
        match = pattern.match(line)
        if match:
            return match.group(1)
    return None


def open_shortcut(shortcut_name: str) -> None:
    '''
    Open a shortcut in the Shortcuts editor
    '''

    if not shortcut_exists(shortcut_name):
        print(f"Error: '{shortcut_name}' does not appear to match the name of a shortcut in your library")
        sys.exit(1)

    try:
        subprocess.run(
            ['shortcuts', 'view', shortcut_name],
            check=True
        )
    except subprocess.CalledProcessError:
        print(f"Error: Unable to open shortcut '{shortcut_name}'")
        sys.exit(1)


def get_icloud_url(shortcut_name: str) -> str:
    '''
    Create an iCloud Share URL for a shortcut in your library

    This function uses an external utility shortcut to create the iCloud URL for the given shortcut.
    Please ensure you have added this shortcut to your library.

    Get iCloud URL Non-Interactive
    https://www.icloud.com/shortcuts/2004684ce9b44a00854db22f87b1883e
    '''
    
    if not shortcut_exists(shortcut_name):
        print(f"Error: No shortcut named '{shortcut_name}' was found in your Shortcuts Library")
        sys.exit(1)

    utility_shortcut = "Get iCloud URL Non-Interactive"

    try:
        process = subprocess.run(
            ['shortcuts', 'run', utility_shortcut, '-i', shortcut_name, '-o', '-'],
            capture_output=True,
            check=True
        )
        url = base64.b64decode(process.stdout)
        return url.decode('utf-8').removesuffix('\n')
    except subprocess.CalledProcessError:
        print(f"Error: Unable to get iCloud Share URL for shortcut '{shortcut_name}'")
        sys.exit(1)


def get_icloud_url_identifier(icloud_url: str) -> str:
    '''
    Extract the unique identifier from a Shortcuts/iCloud Share URL
    '''
    components = urlparse(icloud_url)
    if components.netloc == 'www.icloud.com' and components.path.startswith('/shortcuts/'):
        identifier = components.path.removeprefix('/shortcuts/')
        return identifier
    else:
        print(f"Error: Invalid iCloud URL '{icloud_url}'")
        print('\tThe URL should conform to the following structure: https://www.icloud.com/shortcuts/<SHORTCUT_ID>')
        sys.exit(1)

        
def import_shortcut(path_or_url: str, isURL: bool = False) -> None:
    '''
    Import a shortcut to your Shortcuts Library via opening a shortcut file or iCloud Share URL
    '''

    if isURL:
        identifier = get_icloud_url_identifier(path_or_url)
        import_url = f"shortcuts://shortcuts/{identifier}"
        try:
            subprocess.run(
                ['open', import_url],
                check=True
            )
        except subprocess.CalledProcessError:
            print(f"Error: Unable to import shortcut from URL '{path_or_url}'")
            sys.exit(1)

    else:
        file = Path(path_or_url).resolve()
        if not file.exists():
            print(f"Error: '{str(file)}' does not appear to exist")
            sys.exit(1)

        if not file.is_file():
            print(f"Error: path '{str(file)}' exists but does not appear to be a file")
            sys.exit(1)
        
        try:
            subprocess.run(
                ['open', '-a', 'Shortcuts', str(file)],
                check=True
            )
        except subprocess.CalledProcessError:
            print(f"Error: Unable to import shortcut file '{file.name}'")
            sys.exit(1)


def create_shortcut() -> None:
    '''
    Create a new shortcut in the Shortcuts Editor
    '''

    try:
        url = 'shortcuts://create-shortcut'
        subprocess.run(
            ['open', url],
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f'Error: Unable to create new shortcut\n{e}')
        sys.exit(1)


def export_shortcuts(
        save_dir: str,
        names: list[str],
        all: bool = False,
        compressed: bool = False,
        organize: bool = False,
        compression_algo: Optional[str] = None,
        supported_algos: Literal['zip', 'tar.gz', 'tar.bz2', 'tar.xz', 'tar', 'gz', 'cpio', 'iso'] = 'zip'
    ) -> None:
    '''
    Export shortcuts from your library, optionally compressing and/or organizing them.

    Supported compression formats:
        - zip
        - tar.gz
        - tar.bz2
        - tar.xz
        - tar
        - gz
        - cpio
        - iso

    This function uses an external utility shortcut to export the shortcuts from your library.
    Please ensure you have added this shortcut to your library:

    Export Shortcuts Non-Interactive
    https://www.icloud.com/shortcuts/1e572591a5dd4d23850a0a6c2b289aa9
    '''

    utility_shortcut = 'Export Shortcuts Non-Interactive'

    names = [name for name in names if shortcut_exists(name)]

    if not all and not names:
        print("Error: No shortcuts matching the names provided were found")
        sys.exit(1)

    if compressed and compression_algo not in supported_algos:
        print(f"Error: '{compression_algo}' is not a supported compression algorithm")
        print(f"Supported Algorithms: {supported_algos}")
        sys.exit(1)

    save_path = Path(save_dir).resolve()
    save_path.mkdir(parents=True, exist_ok=True)

    options = {
        "names": names,
        "all": all,
        "compressed": compressed,
        "compression_algo": f".{compression_algo}"
    }

    try:
        options_json = json.dumps(options)
        process = subprocess.run(
            ['shortcuts', 'run', utility_shortcut, '-i', '-'],
            input=options_json.encode('utf-8'),
            capture_output=True,
            check=True
        )
        encoded_data = process.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error: Unable to export shortcuts\n{e}")
        sys.exit(1)

    zip_data = base64.b64decode(encoded_data)
    zip_buffer = BytesIO(zip_data)

    creation_date = datetime.now().strftime("%Y-%m-%d")

    if compressed:
        if organize:
            export_dir = save_path / "Shortcut Exports"
            export_dir.mkdir(parents=True, exist_ok=True)
        else:
            export_dir = save_path
        output_path = export_dir / f"Shortcuts export {creation_date}.{compression_algo}"
        output_path.write_bytes(zip_buffer.getvalue())
    else:
        with ZipFile(zip_buffer) as zip_file:
            if organize:
                for item in zip_file.namelist():
                    item_name = Path(item).stem
                    output_dir = save_path / item_name
                    output_dir.mkdir(parents=True, exist_ok=True)
                    zip_file.extract(item, path=output_dir)
            else:
                zip_file.extractall(path=save_path)


def compare_shortcuts(name1: str, name2: str) -> None:
    '''
    Generate a unified diff of two shortcuts
    '''

    for name in [name1, name2]:
        if not shortcut_exists(name):
            print(f"Error: '{name}' does not appear to match the name of a shortcut in your library")
            sys.exit(1)
    
    shortcut1 = get_shortcut_plist(name1, output_dict=False).splitlines(keepends=True)
    shortcut2 = get_shortcut_plist(name2, output_dict=False).splitlines(keepends=True)

    diff = difflib.unified_diff(
        shortcut1,shortcut2,
        fromfile=f'{name1}.shortcut',
        tofile=f'{name2}.shortcut',
        lineterm=''
    )

    unified_diff = ''.join(diff)

    if diff:
        print(unified_diff)
    else:
        print("✅ No differences detected")


def build_shortcuts_url(
        shortcut_name: Optional[str] = None,
        run: bool = True,
        open: bool = False,
        create: bool = False,
        import_link: bool = False,
        gallery: bool = False,
        automations: bool = False,
        input_type: str = 'text',
        text: Optional[str] = None,
        x_callback: bool = False,
        x_success_url: Optional[str] = None,
        x_cancel_url: Optional[str] = None,
        x_error_url: Optional[str] = None
        ) -> str:
    '''
    Construct a shortcuts URL for running, opening, importing, and creating shortcuts.

    The parameter 'input' can either be 'text' or 'clipboard'

    Note:
        Certain URL routes such as 'create', 'gallery', and 'automations' don't take any
        parameters and cannot be used to create new shortcuts with a pre-filled name fields
        nor can they be used navigate to specific automations or items Shortcuts gallery.

        Thus for these routes, the base URL will be output
    '''
    
    if create:
        return 'shortcuts://create-shortcut'
    
    if gallery:
        return 'shortcuts://gallery'
    
    if automations:
        return 'shortcuts://automations'
    
    if open:
        name = quote(shortcut_name, safe='')
        return f'shortcuts://open-shortcut?name={name}'
    
    if import_link:
        if not shortcut_exists(shortcut_name):
            print(f"Error: Unable to build an import URL for a non-existent shortcut")
            sys.exit(1)
        else:
            icloud_url = get_icloud_url(shortcut_name)
            identifier = get_icloud_url_identifier(icloud_url)
            return f"shortcuts://shortcuts/{identifier}"
    
    if run:
        name = quote(shortcut_name, safe='')
        if not x_callback:
            # text input
            if input_type == 'text':
                input_text = quote(text, safe='')
                return f"shortcuts://run-shortcut?name={name}&input={input_type}&text={input_text}"
            # clipboard input
            elif input_type == 'clipboard':
                return f"shortcuts://run-shortcut?name={name}&input={input_type}"
            # invalid input type
            else:
                print(f"Error: Invalid input type '{input_type}'\nAccepted input types: 'text', 'clipboard'")
                sys.exit(1)
        else:
            x_success = quote(x_success_url, safe='')
            x_cancel = quote(x_cancel_url, safe='')
            x_error = quote(x_error_url, safe='')

            # text input
            if input_type == 'text':
                input_text = quote(text, safe='')
                return f"shortcuts://x-callback-url/run-shortcut?name={name}&input={input_type}&text={input_text}&x-success={x_success}&x-cancel={x_cancel}&x-error={x_error}"
            # clipboard input
            elif input_type == 'clipboard':
                return f"shortcuts://x-callback-url/run-shortcut?name={name}&input={input_type}&x-success={x_success}&x-cancel={x_cancel}&x-error={x_error}"
            # invalid input type
            else:
                print(f"Error: Invalid input type '{input_type}'\nAccepted input types: 'text', 'clipboard'")
                sys.exit(1)


def sign_shortcut(
        input_path: str,
        output_path: str,
        signing_mode: Literal['anyone', 'people-who-know-me'] = 'anyone',
        add_to_library: bool = False
        ) -> None:
    '''
    Sign a shortcut plist file (i.e, '.wflow', '.shortcut', '.plist') and output a signed shortcut ready for import
    '''
    
    # expanduser is called just in case either path contains an unexpanded tilde
    input_file = Path(input_path).expanduser().resolve()
    output_file = Path(output_path).expanduser().resolve()
    

    if not input_file.exists():
        print(f"Error: Invalid path '{input_file.__str__()}'")
        sys.exit(1)

    # If the input file has the .plist extension, rename it with the .wflow extension so /usr/bin/shortcuts cooperates
    if input_file.suffix == '.plist':
        old_suffix = input_file.suffix
        input_file = input_file.rename(input_file.with_suffix('.wflow'))

    try:
        process = subprocess.run(
            ['shortcuts', 'sign', '-i', str(input_file), '-m', signing_mode, '-o', str(output_file)],
            check=True,
            stderr=subprocess.DEVNULL
        )
        if not output_file.exists():
            print(f"Error: Unable to sign '{input_file.__str__()}'")
            sys.exit(1)

        if add_to_library:
            import_shortcut(str(output_file))

        # Rename the input file back to it's original suffix
        if old_suffix:
            input_file.rename(input_file.with_suffix(old_suffix))

    except subprocess.CalledProcessError as e:
        print(f"Error: Unable to sign '{input_file.__str__()}'")
        print(' '.join(e.args))
        sys.exit(1)


def run_shortcut(
    shortcut_name: str,
    shortcut_input: Optional[str] = None,
    input_is_file: bool = False,
    shortcut_output: Optional[str] = None,
    output_uti: Optional[str] = None
) -> None:
    '''
    Run a shortcut, optionally providing input and/or specifying an output destination.

    Parameters:
    - shortcut_name: The name or UUID of a Shortcut.
    - shortcut_input: File path, '-' for stdin, or literal string input.
    - input_is_file: If True, treat shortcut_input as a file path.
    - shortcut_output: File path to write output, or '-' for stdout.
    - output_uti: Uniform Type Identifier (UTI) of output type.
    '''
    command = ['shortcuts', 'run', shortcut_name]

    process_input = None

    if shortcut_input:
        command.extend(['-i', '-'])

        if input_is_file:
            input_path = Path(shortcut_input).expanduser().resolve()
            if not input_path.exists():
                print(f"Error: Input file '{input_path}' not found.", file=sys.stderr)
                sys.exit(1)
            process_input = input_path.read_bytes()
        elif shortcut_input == '-':
            process_input = sys.stdin.buffer.read()
        else:
            process_input = shortcut_input.encode('utf-8')

    if shortcut_output:
        if shortcut_output == '-':
            command.extend(['-o', '-'])
        else:
            output_path = Path(shortcut_output).expanduser().resolve()
            command.extend(['-o', str(output_path)])

        if output_uti:
            command.extend(['--output-type', output_uti])

    try:
        process = subprocess.run(
            command,
            input=process_input,
            capture_output=True,
            check=True
        )

        if shortcut_output == '-' or not shortcut_output:
            if process.stdout:
                sys.stdout.buffer.write(process.stdout)
                sys.stdout.buffer.flush()
        if process.stderr:
            print(process.stderr.decode('utf-8'), file=sys.stderr)

    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def is_valid_time_interval(interval: str) -> bool:
    '''
    Validate that the given time interval is in a valid format used by the log command

    Examples of valid intervals:
        - 10m  # 10 minutes
        - 4h   # 4 hours
        - 2d   # 2 days
    '''
    result = re.search(r'^[0-9]+[mhd]{1}$', interval)
    return True if result else False


def is_valid_timestamp(timestamp: str) -> bool:
    '''
    Validate that the given start or end time strings are in valid datetime formats used by the log command

    Valid formats:
        - YYYY-MM-DD
        - YYYY-MM-DD HH:MM:SS
        - YYYY-MM-DD HH:MM:SSZZZZZ
    '''
    result = re.search(r'\b\d{4}-\d{2}-\d{2}(?:[ ]\d{2}:\d{2}:\d{2}(?:[+-]\d{4})?)?\b', timestamp)
    return True if result else False


def is_valid_export_size(size: str) -> bool:
    '''
    Validate that the given export size string is in a valid format used by the log command

    Examples of valid sizes:
        - 100k  # 100 kilobytes
        - 20m   # 20 megabytes
    '''
    result = re.search(r'^[0-9]+[km]{1}$', size)
    return True if result else False


def is_valid_UDID(identifier: str) -> bool:
    '''
    Validate that the given device UDID is valid. Supports old and new style UDIDs
    '''
    result = re.search(r'\b(?:[a-f0-9]{40}|[0-9a-fA-F]{8}-[0-9a-fA-F]{16})\b', identifier)
    return True if result else False


def build_predicate(
    subsystem_category: Optional[str] = None,
    sender_image: Optional[str] = None,
    process_name: Optional[str] = None,
    include_events: Optional[list[Literal['info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction']]] = None
    ) -> str:
    '''
    Build a predicate for filtering shortcut logs
    '''
    base_predicate = 'subsystem == "com.apple.shortcuts"'

    if subsystem_category:
        base_predicate += f' AND category == "{subsystem_category}"'

    if sender_image:
        base_predicate += f' AND sender == "{sender_image}"'
    
    if process_name:
        base_predicate += f' AND process == "{process_name}"'

    event_type_filters = {
        'activity': 'eventType == activityCreateEvent',
        'transition': 'eventType == activityTransitionEvent',
        'state': 'eventType == stateEvent',
        'timesync': 'eventType == timesyncEvent',
        'userAction': 'eventType == userActionEvent',
        'signpost': 'eventType == signpostEvent',
        'loss': 'eventType == lossEvent',
        'trace': 'eventType == traceEvent'
    }

    message_type_filters = {
        'info': 'messageType == info',
        'default': 'messageType == default',
        'debug': 'messageType == debug',
        'error': 'messageType == error',
        'fault': 'messageType == fault'
    }

    event_filters_selected = []
    message_filters_selected = []

    if include_events:
        for event in include_events:
            if event in event_type_filters:
                event_filters_selected.append(event_type_filters[event])
            elif event in message_type_filters:
                message_filters_selected.append(message_type_filters[event])

    combined_filters = []

    if event_filters_selected:
        combined_filters.append('(' + ' OR '.join(event_filters_selected) + ')')

    if message_filters_selected:
        combined_filters.append('(' + ' OR '.join(message_filters_selected) + ')')

    if combined_filters:
        predicate = f"{base_predicate} AND {' AND '.join(combined_filters)}"
    else:
        predicate = base_predicate

    return predicate


def process_with_environment(command: list[str], environment: dict) -> None:
    '''
    Spawn a process in a pseudo-terminal environment.
    Used to show colored output in the 'logs' subcommand.
    '''
    pid, file_descriptor = pty.fork()
    if pid == 0:
        os.execvpe(command[0], command, environment)
    else:
        try:
            while True:
                output = os.read(file_descriptor, 1024)
                if not output:
                    break
                sys.stdout.buffer.write(output)
                sys.stdout.buffer.flush()
        except OSError:
            pass


def export_shortcut_logs(
    predicate: str,
    output_path: str,
    time_interval: Optional[str] = None,
    start: Optional[str] = None,
    end: Optional[str] = None,
    log_size: Optional[str] = None,
    from_first_paired_device: bool = False,
    device_name: Optional[str] = None,
    device_udid: Optional[str] = None,
    ) -> None:
    '''
    Export shortcut logs from this device or a paired device to a new logarchive, optionally filtering the logs
    '''

    command = ['log', 'collect', '--predicate', predicate]

    save_path = Path(output_path).expanduser().resolve()

    if save_path.suffix:
        if save_path.suffix != '.logarchive':
            print(f"Error: Invalid export path '{str(output_path)}'")
            print("Output path must either be a directory or have the suffix .logarchive")
            sys.exit(1)
        else:
            command.extend(['--output', str(save_path)])
    else:
        save_path.mkdir(parents=True, exist_ok=True)
        filename = f"Shortcuts logs {datetime.now().strftime("%Y-%m-%d")}.logarchive"
        save_path = save_path / filename 
        command.extend(['--output', str(save_path)])

    if time_interval:
        if not is_valid_time_interval(time_interval):
            print(f"Warning: Invalid time interval '{time_interval}'. Ignoring ...")
        else:
            command.extend(['--last', time_interval])

    if start:
        if not is_valid_timestamp(start):
            print(f"Warning: Invalid timestamp '{start}'. Ignoring ...")
        else:
            command.extend(['--start', start])

        if end:
            if not is_valid_timestamp(end):
                print(f"Warning: Invalid timestamp '{end}'. Ignoring ...")
            else:
                command.extend(['--end', end])

    if log_size:
        if not is_valid_export_size(log_size):
            # Exit if a log size is provided but is invalid
            print(f"Error: Invalid export size '{log_size}'")
            sys.exit(1)
        else:
            command.extend(['--size', log_size])
    
    if from_first_paired_device:
        command.extend('--device')
    
    if device_name:
        command.extend(['--device-name', device_name])
    
    if device_udid:
        if is_valid_UDID(device_udid):
            command.extend(['--device-udid', device_udid])
        else:
            # Exit if a UDID is provided but is invalid
            print(f"Error: Invalid UDID '{device_udid}'")
            sys.exit(1)
    
    try:
        print("Creating a new logarchive ... This could take a long time")
        subprocess.run(
            command,
            check=True,
            stderr=subprocess.DEVNULL
        )
    except subprocess.CalledProcessError as e:
        print(f"Error while running command '{command}'")
        print(e)
        sys.exit(1)


def stream_shortcut_logs(
    predicate: str,
    show_color: bool = True,
    process: Optional[Union[str, int]] = None,
    log_format: Literal['default', 'compact', 'json', 'syslog'] = 'default',
    timeout: Optional[str] = None,
    include_source: bool = False,
    ) -> None:
    '''
    Stream events from the Shortcuts subsystem log, optionally filtering the formatting the output
     
    Optional filters:
        - process (either a process name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)
        - subsystem category (e.g, "General", "Database", "Dialog", "Editor", "Workflow", "WorkflowExecution", "XPCEvent", ...) # NOTE: As well as many other options not listed here
        - sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)
        - events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')
        - include source symbols and line numbers when available

    Output formatting:
        - colored output
        - log format (e.g, "default", "compact", "json", "syslog")
    '''

    log_formats = ['default', 'compact', 'json', 'syslog']
    
    colorable_formats = ['default', 'compact']

    command = ['log', 'stream', '--predicate', predicate]
    
    if process is not None:
        command.extend(['--process', process])

    if include_source:
        command.extend(['--source'])

    if log_format and log_format in log_formats:
        command.extend(['--style', log_format])
    else:
        command.extend(['--style', 'default'])
    
    if show_color:
        if log_format not in colorable_formats:
            command.extend(['--color', 'none'])
        command.extend(['--color', 'always'])

    if timeout:
        if not is_valid_time_interval(timeout):
            # Exit if a timeout was provided but was invalid so the process dosen't run in the background forever
            print(f"Error: Invalid timeout interval '{timeout}'.")
            sys.exit(1)
        else:
            command.extend(['--timeout', timeout])
    
    try:
        env = os.environ.copy()
        env.update({
        'TERM': 'xterm-256color',
        'CLICOLOR_FORCE': '1',
        'CLICOLOR': '1'
        })
        print("Streaming logs... Press Ctrl+C to stop.\n")
        process_with_environment(command, environment=env)
    except KeyboardInterrupt:
        # The user manually stopped the stream with Ctrl+C
        print('\nStopping stream ...')
        sys.exit()
    except Exception as e:
        print(f"Error while running command: '{command}'")
        print(e)
        sys.exit(1)


def view_shortcuts_logs(
    predicate: str,
    show_color: bool = True,
    from_archive: Optional[str] = None,
    time_interval: Optional[str] = None,
    start: Optional[str] = None,
    end: Optional[str] = None,
    process: Optional[Union[str, int]] = None,
    include_source: bool = False,
    log_format: Literal['default', 'compact', 'json', 'ndjson', 'syslog'] = 'default',
) -> None:
    '''
    View events from the Shortcuts subsystem log, optionally filtering and formatting the output
     
    Optional filters:
        - time interval (e.g, "5m", "3h", "1d", or "boot" for minutes, hours, days, and since last reboot respectively)
        - start date/time (acceptable formats "YYYY-MM-DD", "YYYY-MM-DD HH:MM:SS", "YYYY-MM-DD HH:MM:SSZZZZZ")
        - end date/time (acceptable formats "YYYY-MM-DD", "YYYY-MM-DD HH:MM:SS", "YYYY-MM-DD HH:MM:SSZZZZZ")
        - process (either a process name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)
        - sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)
        - subsystem category (e.g, "General", "Database", "Dialog", "Editor", "Workflow", "WorkflowExecution", "XPCEvent", ...) # NOTE: As well as many other options not listed here
        - events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')
        - include source symbols and line numbers when available

    Optional output formatting:
        - colored output
        - log format (e.g, "default", "compact", "json", "ndjson", "syslog")
    '''

    log_formats = ['default', 'compact', 'json', 'ndjson', 'syslog']

    colorable_formats = ['default', 'compact']

    command = ['log', 'show', '--predicate', predicate]

    if process is not None:
        command.extend(['--process', process])

    if include_source:
        command.extend(['--source'])

    if log_format and log_format in log_formats:
        command.extend(['--style', log_format])
    else:
        command.extend(['--style', 'default'])
    
    if show_color:
        if log_format not in colorable_formats:
            command.extend(['--color', 'none'])
        command.extend(['--color', 'always'])
    
    if time_interval:
        if not is_valid_time_interval(time_interval) and not time_interval == 'boot':
            print(f"Warning: Invalid time interval '{time_interval}'. Ignoring ...")
        else:
            command.extend(['--last', time_interval])
    
    if start:
        if not is_valid_timestamp(start):
            print(f"Warning: Invalid timestamp '{start}'. Ignoring ...")
        else:
            command.extend(['--start', start])

        if end:
            if not is_valid_timestamp(end):
                print(f"Warning: Invalid timestamp '{end}'. Ignoring ...")
            else:
                command.extend(['--end', end])

    if from_archive:
        archive_path = Path(from_archive).resolve()
        if not archive_path.exists() or not archive_path.suffix == '.logarchive':
            # Exit here since the user explicitly wants to view logs from a logarchive and the path is invalid
            print(f"Error: Invalid logarchive path '{str(archive_path)}'")
            sys.exit(1)
        command.extend(['--archive', str(archive_path)])
    
    try:
        env = os.environ.copy()
        env.update({
        'TERM': 'xterm-256color',
        'CLICOLOR_FORCE': '1',
        'CLICOLOR': '1'
        })
        process_with_environment(command, environment=env)
    except Exception as e:
        print(f"Error running command: '{command}'")
        print(e)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        prog='shortcut-util',
        description="Apple Shortcuts Utility",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "\033[37mExamples:\033[0m\n"
            "  shortcut-util run -n 'My Shortcut' -i 'Some Data'\n"
            "  cat MyFile.txt | shortcut-util run -n 'My Shortcut' -i - -o -\n"
            "  shortcut-util run -n 'My Shortcut' -i 'MyFile.json' -o 'MyResult.plist' --output-uti 'com.apple.property-list'\n"
            "  shortcut-util get-actions <shortcut-name>\n"
            "  shortcut-util count-actions <shortcut-name>\n"
            "  shortcut-util convert <shortcut-name> --json\n"
            "  shortcut-util convert <shortcut-name> --plist\n"
            "  shortcut-util convert <shortcut-name> --plist -s <save-destination> --file-extension shortcut\n"
            "  shortcut-util convert <shortcut-name> --plist --save-dir <save-destination> -f wflow\n"
            "  shortcut-util get-uuid <shortcut-name>\n"
            "  shortcut-util open <shortcut-name>\n"
            "  shortcut-util import <path-to-shortcut-file>\n"
            "  shortcut-util import <shortcut-share-url> --url\n"
            "  shortcut-util create\n"
            "  shortcut-util icloud-url <shortcut-name>\n"
            "  shortcut-util export -n <shortcut-name> -s <save-destination>\n"
            "  shortcut-util export --names <shortcut1> <shortcut2> --save-dir <save-destination> --organize\n"
            "  shortcut-util export --all -s <save-destination> --compressed -algo tar.gz\n"
            "  shortcut-util diff <shortcut1> <shortcut2>\n"
            "  shortcut-util build-url --run --name <shortcut-name> --type text --text 'This is some example input text'\n"
            "  shortcut-util build-url --open --name <shortcut-name>\n"
            "  shortcut-util build-url --run --name <shortcut-name> --type clipboard --x-callback --success <x-success-url> --cancel <x-cancel-url> --error <x-error-url>\n"
            "  shortcut-util build-url --import-link --name <shortcut-name>\n"
            "  shortcut-util build-url --automations\n"
            "  shortcut-util build-url --gallery\n"
            "  shortcut-util build-url --create\n"
            "  shortcut-util sign -i <input-plist-path> -m people-who-know-me -o <output-shortcut-path>\n"
            "  shortcut-util sign --input <input-plist-path> --signing-mode anyone --output <output-shortcut-path> --add-to-library\n"
            "  shortcut-util logs view --last 10h\n"
            "  shortcut-util logs view --last 10h --process BackgroundShortcutRunner --sender WorkflowKit --category Workflow --format json\n"
            "  shortcut-util logs stream --timeout 5m\n"
            "  shortcut-util logs stream --timeout 2m --format compact --include info debug error fault userAction\n"
            "  shortcut-util logs export --last 24h --output ~/Shortcut Logs.logarchive\n"
            '  shortcut-util logs export --last 24h --process Shortcuts --device-name "Bob\'s iPhone" --output ~/Shortcut Logs.logarchive\n'
        )
    )
    subparsers = parser.add_subparsers(dest='command', required=True, help='\033[37mSubcommands\033[0m')

    # get-actions parser
    get_actions_parser = subparsers.add_parser('get-actions', help='Extract the actions from a Shortcut')
    get_actions_parser.add_argument('name', help='The name of the Shortcut to parse')
    get_actions_parser.add_argument('-j', '--json', action='store_true', help='Output actions in JSON format')
    get_actions_parser.add_argument('-i', '--identifiers', action='store_true', help='Output a list of shortcut action identifiers present in the shortcut')

    # count-actions parser
    count_actions_parser = subparsers.add_parser('count-actions', help='Count the actions in a Shortcut')
    count_actions_parser.add_argument('name', help='The name of the Shortcut')

    # convert parser
    convert_parser = subparsers.add_parser('convert', help="Convert a Shortcut to JSON or PLIST")
    convert_parser.add_argument('name', help="The name of the Shortcut to convert")
    convert_parser.add_argument('-j','--json', action='store_true', help="Convert the Shortcut to JSON")
    convert_parser.add_argument('-p','--plist', action='store_true', help="Convert the Shortcut to PLIST")
    convert_parser.add_argument('-s', '--save-dir', type=str, default='.', help='The directory to save the converted shortcut to')
    convert_parser.add_argument('-f', '--file-extension', type=str, help="The extension to associate with the saved file. This can either be 'wflow', 'shortcut', 'plist', or 'json'.\nNote: Only files with the extensions '.wflow' '.shortcut' can be signed")

    # get-uuid parser
    get_uuid_parser = subparsers.add_parser('get-uuid', help="Get the UUID of a Shortcut")
    get_uuid_parser.add_argument('name', help="The name of the Shortcut to retrieve the UUID of")

    # open parser
    open_parser = subparsers.add_parser('open', help='Open a shortcut in the Shortcuts Editor')
    open_parser.add_argument('name', help='The name of the Shortcut to open')

    # import parser
    import_parser = subparsers.add_parser('import', help="Import a shortcut file into your Shortcuts Library")
    import_parser.add_argument('path_or_url', help='The path to the shortcut file or the iCloud Share URL of the shortcut to import')
    import_parser.add_argument('--url', action='store_true', help='Import the shortcut from an iCloud Share URL')

    # create parser
    create_parser = subparsers.add_parser('create', help='Create a new shortcut in the Shortcuts Editor')

    # icloud-url parser
    icloud_url_parser = subparsers.add_parser('icloud-url', help='Create an iCloud Share URL for a shortcut in your library')
    icloud_url_parser.add_argument('name', help='The name of the shortcut to create the iCloud Share URL for')

    # export parser
    export_parser = subparsers.add_parser('export', help="Export shortcuts from your library, optionally compressing and/or organizing them into folders")
    export_parser.add_argument('-n', '--names', nargs='+', type=str, default=[], help='The name(s) of the shortcuts to export')
    export_parser.add_argument('-a', '--all', action='store_true', help="Export all shortcuts in your library")
    export_parser.add_argument('-c','--compressed', action='store_true', help="Whether or not to compress the exported shortcuts")
    export_parser.add_argument('-algo', '--compression-algorithim', type=str, default='zip', help="The compression algorithim to use: (zip, tar.gz, tar.bz2, tar.xz, tar, gz, cpio, iso)")
    export_parser.add_argument('-o', '--organize', action='store_true', help="Whether or not to organize the exported shortcuts into folders")
    export_parser.add_argument('-s', '--save-dir', type=str, default='.', help="The directory to save the exported shortcuts to")

    # diff parser
    diff_parser = subparsers.add_parser('diff', help="Generate a unified diff of two shortcuts for comparison")
    diff_parser.add_argument('name1', type=str, help='The first shortcut to compare')
    diff_parser.add_argument('name2', type=str, help='The second shortcut to compare')

    # build-url parser
    build_url_parser = subparsers.add_parser('build-url', help="Construct a shortcuts URL for running, opening, and creating shortcuts")
    build_url_parser.add_argument('-n', '--name', type=str, help='The name of the shortcut to build the run/open URL for')
    build_url_parser.add_argument('-r', '--run', action='store_true', help="Build a URL for running shortcuts")
    build_url_parser.add_argument('-o', '--open', action='store_true', help="Build a URL for opening shortcuts")
    build_url_parser.add_argument('-c', '--create', action='store_true', help="Build a URL for opening a new shortcut in the Shortcut Editor")
    build_url_parser.add_argument('-I', '--import-link', action='store_true', help="Build a URL for importing shortcuts into your Shortcuts Library")
    build_url_parser.add_argument('-g','--gallery', action='store_true', help="Build a URL to open the Shortcuts Gallery")
    build_url_parser.add_argument('-a', '--automations', action='store_true', help="Build a URL for opening the Automations tab in the Shortcuts app")
    build_url_parser.add_argument('-t', '--type', type=str, help="The type of shortcut input. This can be either 'text' or 'clipboard'")
    build_url_parser.add_argument('-T', '--text', type=str, help="The text to use as input to the shortcut")
    build_url_parser.add_argument('-x', '--x-callback', action='store_true', help='Build an X-Callback-URL')
    build_url_parser.add_argument('--success', type=str, help="The URL to open if the shortcut runs successfully")
    build_url_parser.add_argument('--cancel', type=str, help="The URL to open if the shortcut run was cancelled")
    build_url_parser.add_argument('--error', type=str, help="The URL to open if an error occurs while the shortcut is running")

    # sign parser
    sign_parser = subparsers.add_parser('sign', help="Sign a shortcut plist file and output a signed shortcut")
    sign_parser.add_argument('-i', '--input', type=str, help='The path to the shortcut plist file. Acceptable file-extensions: (.shortcut, .wflow, .plist)')
    sign_parser.add_argument('-m', '--signing-mode',type=str, default='anyone', help='Whether to sign the shortcut for anyone to use, or for personal use (only you and people who have you in their contacts will be able to use it)')
    sign_parser.add_argument('-o', '--output', type=str, help='The path to save the signed shortcut to')
    sign_parser.add_argument('-L', '--add-to-library', action='store_true', help='Whether to import the signed shortcut to your Shortcuts Library after processing')

    # run parser
    run_parser = subparsers.add_parser('run', help="Run a Shortcut in your library")
    run_parser.add_argument('-n', '--name', type=str, help="The name or UUID of the shortcut to run")
    run_parser.add_argument('-i', '--input', type=str, help="The input to provide to the shortcut. Use '-' to read from stdin")
    run_parser.add_argument('--file', action='store_true', help="Treat the input argument as a file")
    run_parser.add_argument('-o', '--output', type=str, help="The output destination. Can either be a file path or '-' to write the output to stdout")
    run_parser.add_argument('--output-uti', type=str, help="The Uniform Type Identifier to output the data in")

    # logs parser
    logs_parser = subparsers.add_parser('logs', help="View, stream or export Shortcuts logs")
    logs_subparsers = logs_parser.add_subparsers(dest='logs_command', required=True)

    # view logs subparser
    view_parser = logs_subparsers.add_parser('view', help="View Shortcuts logs, optionally filtering them")
    view_parser.add_argument('--color', action='store_true', help="Show colored output")
    view_parser.add_argument('--from-archive', type=str, help="View matching logs in a logarchive")
    view_parser.add_argument('--last', type=str, help="View log events from the given time interval. (e.g, 20m, 4h, 2d, boot for minutes, hours, days and the time since last reboot respectively)")
    view_parser.add_argument('--start', type=str, help="View events from the given start date on (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    view_parser.add_argument('--end', type=str, help="View events until the given end date. Requires --start (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    view_parser.add_argument('--process', type=str, help='View log events created by a specific process (process-name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)')
    view_parser.add_argument('--format', type=str, help='log format (e.g, "default", "compact", "json", "ndjson", "syslog")')
    view_parser.add_argument('--source', action='store_true', help="Include line numbers and symbols when available")
    view_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    view_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    view_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    # stream logs subparser
    stream_parser = logs_subparsers.add_parser('stream', help="Stream Shortcuts logs, optionally filtering them")
    stream_parser.add_argument('--color', action='store_true', help="Show colored output")
    stream_parser.add_argument('--process', type=str, help='Include only log events created by a specific process (process-name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)')
    stream_parser.add_argument('--format', type=str, help='log format (e.g, "default", "compact", "json", "syslog")')
    stream_parser.add_argument('--timeout', type=str, help="Exit after the given time interval has elapsed (e.g, 20m, 4h, 2d, boot for minutes, hours, and days respectively)")
    stream_parser.add_argument('--source', action='store_true', help="Include line numbers and symbols when available")
    stream_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    stream_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    stream_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    # export logs parser
    export_logs_parser = logs_subparsers.add_parser('export', help='Export Shortcut logs to a logarchive, optionally filtering them')
    export_logs_parser.add_argument('-o', '--output', type=str, help="The path to save the created logarchive to")
    export_logs_parser.add_argument('--last', type=str, help="Include log events from the given time interval. (e.g, 20m, 4h, 2d for minutes, hours, and days respectively)")
    export_logs_parser.add_argument('--start', type=str, help="Include events from the given start date on (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")    
    export_logs_parser.add_argument('--end', type=str, help="Include events until the given end date. Requires --start (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    export_logs_parser.add_argument('--size', type=str, help="The size to the limit the logarchive to (acceptable formats: 100k, 20m for kilobytes and megabytes respectively)")
    export_logs_parser.add_argument('--first-device', action='store_true', help="Export logs from the first paired device found")
    export_logs_parser.add_argument('--device-name', type=str, help="Export logs from a paired device with the given name")
    export_logs_parser.add_argument('--UDID', type=str, help="Export logs from a paired device with the given UDID")
    export_logs_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    export_logs_parser.add_argument('--process', type=str, help="Include log events created by a specific process (process name only)")
    export_logs_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    export_logs_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    args = parser.parse_args()

    # get-actions main
    if args.command == 'get-actions':
        if not shortcut_exists(args.name):
            print(f"Error: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)
        actions = get_shortcut_actions(plist)
        if args.identifiers:
            output = get_action_ids(actions)
        else:
            output = actions
            
        if args.json:
            print(json.dumps(output, indent=4))
        else:
            print(plistlib.dumps(output, fmt=plistlib.FMT_XML).decode('utf-8'))

    # count-actions main
    elif args.command == 'count-actions':
        if not shortcut_exists(args.name):
            print(f"Error: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)
        actions = get_shortcut_actions(plist)
        print(len(actions))

    # convert main
    elif args.command == 'convert':
        if not shortcut_exists(args.name):
            print(f"Error: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)

        if args.json:
            if args.save_dir:
                save_shortcut(
                    shortcut_data=plist,
                    shortcut_name=args.name,
                    save_destination=args.save_dir,
                    extension='json',
                    isPlist=False
                )
            else:
                print(json.dumps(plist, indent=4))

        elif args.plist:
            if args.save_dir:
                if not args.file_extension:
                    ext = 'plist'
                else:
                    ext = args.file_extension  
                save_shortcut(
                    shortcut_data=plist,
                    shortcut_name=args.name,
                    save_destination=args.save_dir,
                    extension=ext,
                    isPlist=True
                )
            else:
                print(plistlib.dumps(plist, fmt=plistlib.FMT_XML).decode('utf-8'))

    # get-uuid main
    elif args.command == 'get-uuid':
        if not shortcut_exists(args.name):
            print(f"Error: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        uuid = get_shortcut_uuid(args.name)
        if not uuid:
            print(f"Error: UUID for '{args.name}' not found")
            sys.exit(1)
        print(uuid)
    
    # open main
    elif args.command == 'open':
        open_shortcut(args.name)

    # import main
    elif args.command == 'import':
        if args.url:
            import_shortcut(args.path_or_url, isURL=True)
        else:
            import_shortcut(args.path_or_url)
    
    # create main
    elif args.command == 'create':
        create_shortcut()

    # icloud-url main
    elif args.command == 'icloud-url':
        url = get_icloud_url(args.name)
        print(url)
    
    # export main
    elif args.command == 'export':
        export_shortcuts(
            save_dir=args.save_dir,
            names=args.names,
            all=args.all,
            compressed=args.compressed,
            organize=args.organize,
            compression_algo=args.compression_algorithim
        )

    # diff main
    elif args.command == 'diff':
        compare_shortcuts(args.name1, args.name2)

    # build-url main
    elif args.command == 'build-url':
        url = build_shortcuts_url(
            shortcut_name=args.name,
            run=args.run,
            open=args.open,
            create=args.create,
            import_link=args.import_link,
            gallery=args.gallery,
            automations=args.automations,
            input_type=args.type,
            text=args.text,
            x_callback=args.x_callback,
            x_success_url=args.success,
            x_cancel_url=args.cancel,
            x_error_url=args.error
        )
        print(url)

    # sign main
    elif args.command == 'sign':
        valid_modes = ['anyone','people-who-know-me']
        if args.signing_mode not in valid_modes:
            print(f"Error: Invalid signing mode '{args.signing_mode}'.\nAcceptable signing modes: {valid_modes}")
            sys.exit(1)

        if args.add_to_library:
            add_to_library = True
        else:
            add_to_library = False
        
        sign_shortcut(
            input_path=args.input,
            output_path=args.output,
            signing_mode=args.signing_mode,
            add_to_library=add_to_library
        )
    
    # run main
    elif args.command == 'run':
        run_shortcut(
            shortcut_name=args.name,
            shortcut_input=args.input,
            input_is_file=args.file,
            shortcut_output=args.output,
            output_uti=args.output_uti
        )

    # logs main
    elif args.command == 'logs':
        predicate = build_predicate(
            subsystem_category=args.category,
            process_name=args.process,
            sender_image=args.sender,
            include_events=args.include
        )
        if args.logs_command == "view":
            view_shortcuts_logs(
                predicate,
                show_color=args.color,
                from_archive=args.from_archive,
                time_interval=args.last,
                start=args.start,
                end=args.end,
                process=args.process,
                include_source=args.source,
                log_format=args.format
            )
        elif args.logs_command == "stream":
            stream_shortcut_logs(
                predicate,
                show_color=args.color,
                process=args.process,
                log_format=args.format,
                timeout=args.timeout,
                include_source=args.source
            )
        elif args.logs_command == "export":
            export_shortcut_logs(
                predicate,
                output_path=args.output,
                time_interval=args.last,
                start=args.start,
                end=args.end,
                log_size=args.size,
                from_first_paired_device=args.first_device,
                device_name=args.device_name,
                device_udid=args.UDID
            )



if __name__ == "__main__":
    main()