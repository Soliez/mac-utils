#!/usr/bin/env python3

import os
import re
import sys
import pty
import json
import base64
import difflib
import argparse
import plistlib
import subprocess
import importlib.util
from time import sleep
from io import BytesIO
from pathlib import Path
from zipfile import ZipFile
from datetime import datetime
from urllib.parse import urlparse, quote
from typing import Literal, Optional, Any



SCRIPT_PATH = Path(__file__).resolve()
PROJECT_ROOT = SCRIPT_PATH.parent.parent


def get_missing_resource_message(path: str) -> str:
    '''
    Build a message informing the user that there are missing resources files and instruct them on how to fix the issue
    '''
    file = Path(path).resolve()
    lines = [
        f"\033[31mError\033[0m: Missing necessary resource file '{file.name}' from '{str(file.parent)}'\n",
        "\nTo fix this, try one of the following methods:\n",
        "\n1. If you downloaded the script manually, clone the full repository instead and install via Make:",
        "\n\tgit clone https://github.com/Soliez/mac-utils.git && cd mac-utils && make install\n",
        "\n2. If you already cloned the repo but are missing files, move into the project directory and reset it to the latest version:",
        "\n\tgit fetch origin && git reset --hard origin/main"
    ]
    message = ''.join(lines)
    return message


def load_resource(filename: str, data_type: Literal['text', 'binary', 'json', 'plist', 'python'], subdirectories: list[str] = []) -> Any:
    '''
    Project resource file loader
    '''
    valid_data_types = ['text', 'binary', 'json', 'plist', 'python']
    
    if data_type not in valid_data_types:
        print(f"\033[31mError\033[0m: Invalid data type '{data_type}'\nValid types: ({', '.join(valid_data_types)})", file=sys.stderr)
        sys.exit(1)

    if subdirectories:
        resource_file = PROJECT_ROOT / 'resources' / 'shortcut_util' / '/'.join(subdirectories) / filename
    else:
        resource_file = PROJECT_ROOT / 'resources' / 'shortcut_util' / filename

    if not resource_file.exists():
        error_message = get_missing_resource_message(str(resource_file))
        raise FileNotFoundError(error_message)
    
    try:
        if data_type == 'text':
            data = resource_file.read_text()
        elif data_type == 'binary':
            data = resource_file.read_bytes()
        elif data_type == 'json':
            with resource_file.open(mode='rb') as f:
                data = json.load(fp=f)
        elif data_type == 'plist':
            with resource_file.open(mode='rb') as f:
                data = plistlib.load(fp=f)
        elif data_type == 'python':
            spec = importlib.util.spec_from_file_location(resource_file.stem, str(resource_file))
            template_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(template_module)
            data = template_module.get_template()
        return data
    except (PermissionError, IsADirectoryError) as e:
        print(f"\033[31m{type(e).__name__}\033[0m: {os.strerror(e.errno)}", file=sys.stderr)
        sys.exit(1)
    except (json.JSONDecodeError, UnicodeDecodeError) as e:
        if isinstance(e, json.JSONDecodeError):
            print(f"\033[31m{type(e).__name__}\033[0m: Unable to load JSON document '{e.doc}'\nParsing failed on line \033[35m{e.lineno}\033[0m at position \033[35m{e.colno}\033[0m (index \033[35m{e.pos}\033[0m)", file=sys.stderr)
        else:
            print(f"\033[31m{type(e).__name__}\033[0m: Invalid JSON data - {e.reason}", file=sys.stderr)
        sys.exit(1)
    except plistlib.InvalidFileException as e:
        print(f"\033[31m{type(e).__name__}\033[0m: Invalid PLIST data", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"\033[31m{type(e).__name__}\033[0m: An unexpected error occured\n{e}", file=sys.stderr)
        sys.exit(1)
    

def get_shortcut_names() -> list:
    '''
    Get the names of all shortcuts installed on the device as a list
    '''
    command = ['shortcuts', 'list']
    try:
        process = subprocess.run(command, capture_output=True, text=True, check=True)
        return process.stdout.splitlines()
    except subprocess.CalledProcessError as e:
        print("Failed to get shortcut names\n")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def get_shortcut_plist(name: str, output_dict: bool = True) -> dict|str:
    '''
    Convert the shortcut to a XML property-list and output as a dictionary or as a plist string
    
    This function uses a external utility shortcut to convert the shortcut to a plist
    Please ensure you have added this shortcut to your library

    Shortcut to Plist Non-Interactive
    https://www.icloud.com/shortcuts/b6eaf496eeae4eeeb76b4e355e83a641
    '''

    utility_shortcut = "Shortcut to Plist Non-Interactive"
    command = ['shortcuts', 'run', utility_shortcut, '-i', name, '-o', '-']
    try:
        process = subprocess.run(command, capture_output=True, check=True)
        decoded_output = base64.b64decode(process.stdout)
        if output_dict:
            return plistlib.loads(decoded_output)
        else:
            return decoded_output.decode('utf-8')
    except subprocess.CalledProcessError as e:
        print(f"Failed to run utility shortcut '{utility_shortcut}'\n")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)
    except plistlib.InvalidFileException:
        print("Failed to decode plist.")
        sys.exit(1)


def save_shortcut(
        shortcut_data: dict,
        shortcut_name: str,
        save_destination: str,
        extension: str,
        isPlist: bool = True
        ) -> None:
    '''
    Save the converted shortcut to a file

    Acceptable values for 'extension' include:
        - shortcut
        - wflow
        - plist
        - json
    
    Note: Only files with the extension '.shortcut' or '.wflow' can be signed
    '''

    valid_extensions = ['shortcut', 'wflow', 'plist', 'json']

    if not extension in valid_extensions:
        print(f"\033[31mError\033[0m: Invalid extension '{extension}'.\nAcceptable extensions: {valid_extensions}")
        sys.exit(1)

    # expanduser is called just in case 'save_destination' contains an unexpanded tilde
    save_path = Path(save_destination).expanduser().resolve()
    
    # Create the save directory if it doesn't already exist
    save_path.mkdir(parents=True, exist_ok=True)

    save_path = save_path / shortcut_name

    if not isPlist:
        save_path = save_path.with_suffix('.json')
        save_path.write_bytes(json.dumps(shortcut_data).encode('utf-8'))
    else:
        # .shortcut and .wflow files are plists internally
        save_path = save_path.with_suffix(f'.{extension}')
        with open(str(save_path), 'wb') as f:
            plistlib.dump(shortcut_data, fp=f)
    

def get_shortcut_actions(shortcut_dict: dict) -> list[dict]:
    '''
    Extract the actions data from the shortcut dictionary
    '''
    return shortcut_dict.get('WFWorkflowActions', [])


def shortcut_exists(name: str) -> bool:
    '''
    Check whether a shortcut currently exists in your library
    '''
    return name in get_shortcut_names()


def get_action_ids(shortcut_actions: dict) -> list[str]:
    '''
    Get a list of shortcut action identifiers present in the shortcut
    '''
    return [action['WFWorkflowActionIdentifier'] for action in shortcut_actions]


def get_shortcut_uuid(shortcut_name: str) -> str:
    '''
    Retrieve the UUID of a shortcut by its exact name.
    '''
    command = ['shortcuts', 'list', '--show-identifiers']
    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)
    
    pattern = re.compile(rf'^{re.escape(shortcut_name)}\s+\(([A-Za-z0-9\-]+)\)$')

    for line in process.stdout.splitlines():
        match = pattern.match(line)
        if match:
            return match.group(1)
    return None


def open_shortcut(shortcut_name: str) -> None:
    '''
    Open a shortcut in the Shortcuts editor
    '''

    if not shortcut_exists(shortcut_name):
        print(f"\033[31mError\033[0m: '{shortcut_name}' does not appear to match the name of a shortcut in your library")
        sys.exit(1)

    command = ['shortcuts', 'view', shortcut_name]

    try:
        subprocess.run(
            command,
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f"\033[31mError\033[0m: Unable to open shortcut '{shortcut_name}'\n")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def get_icloud_url(shortcut_name: str) -> str:
    '''
    Create an iCloud Share URL for a shortcut in your library

    This function uses an external utility shortcut to create the iCloud URL for the given shortcut.
    Please ensure you have added this shortcut to your library.

    Get iCloud URL Non-Interactive
    https://www.icloud.com/shortcuts/2004684ce9b44a00854db22f87b1883e
    '''
    
    if not shortcut_exists(shortcut_name):
        print(f"\033[31mError\033[0m: No shortcut named '{shortcut_name}' was found in your Shortcuts Library")
        sys.exit(1)

    utility_shortcut = "Get iCloud URL Non-Interactive"
    command = ['shortcuts', 'run', utility_shortcut, '-i', shortcut_name, '-o', '-']

    try:
        process = subprocess.run(
            command,
            capture_output=True,
            check=True
        )
        url = base64.b64decode(process.stdout)
        return url.decode('utf-8').removesuffix('\n')
    except subprocess.CalledProcessError as e:
        print(f"\033[31mError\033[0m: Unable to get iCloud Share URL for shortcut '{shortcut_name}'\n")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def get_icloud_url_identifier(icloud_url: str) -> str:
    '''
    Extract the unique identifier from a Shortcuts/iCloud Share URL
    '''
    components = urlparse(icloud_url)
    if components.netloc == 'www.icloud.com' and components.path.startswith('/shortcuts/'):
        identifier = components.path.removeprefix('/shortcuts/')
        return identifier
    else:
        print(f"\033[31mError\033[0m: Invalid iCloud URL '{icloud_url}'")
        print('\tThe URL should conform to the following structure: https://www.icloud.com/shortcuts/<SHORTCUT_ID>')
        sys.exit(1)

        
def import_shortcut(path_or_url: str, isURL: bool = False) -> None:
    '''
    Import a shortcut to your Shortcuts Library via opening a shortcut file or iCloud Share URL
    '''

    if isURL:
        identifier = get_icloud_url_identifier(path_or_url)
        import_url = f"shortcuts://shortcuts/{identifier}"

        command = ['open', import_url]
        try:
            subprocess.run(
                command,
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"\033[31mError\033[0m: Unable to import shortcut from URL '{path_or_url}'\n")
            print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
            print(e.stderr.decode('utf-8'), file=sys.stderr)
            sys.exit(e.returncode)

    else:
        file = Path(path_or_url).resolve()
        if not file.exists():
            print(f"\033[31mError\033[0m: '{str(file)}' does not appear to exist")
            sys.exit(1)

        if not file.is_file():
            print(f"\033[31mError\033[0m: path '{str(file)}' exists but does not appear to be a file")
            sys.exit(1)
        
        command = ['open', '-a', 'Shortcuts', str(file)]
        try:
            subprocess.run(
                command,
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f"\033[31mError\033[0m: Unable to import shortcut file '{file.name}'\n")
            print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
            print(e.stderr.decode('utf-8'), file=sys.stderr)
            sys.exit(e.returncode)
            

def sign_shortcut(
        input_path: str,
        output_path: str,
        signing_mode: Literal['anyone', 'people-who-know-me'] = 'anyone',
        add_to_library: bool = False
    ) -> None:
    '''
    Sign a shortcut plist file (i.e, '.wflow', '.shortcut', '.plist') and output a signed shortcut ready for import
    '''
    
    input_file = Path(input_path).expanduser().resolve()
    output_file = Path(output_path).expanduser().resolve()

    if not input_file.exists():
        print(f"\033[31mError\033[0m: Invalid path '{input_file}'")
        sys.exit(1)

    old_suffix: Optional[str] = None
    
    # Temporarily rename .plist files to .wflow to satisfy /usr/bin/shortcuts
    if input_file.suffix == '.plist':
        old_suffix = input_file.suffix
        input_file = input_file.rename(input_file.with_suffix('.wflow'))

    try:
        command = ['shortcuts', 'sign', '-i', str(input_file), '-m', signing_mode, '-o', str(output_file)]
        subprocess.run(
            command,
            check=True,
            stderr=subprocess.DEVNULL
        )

        if not output_file.exists():
            print(f"\033[31mError\033[0m: Unable to sign '{input_file}'")
            sys.exit(1)

        if add_to_library:
            import_shortcut(str(output_file))

    except subprocess.CalledProcessError as e:
        print(f"\033[31mError\033[0m: Unable to sign '{input_file}'")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        sys.exit(e.returncode)

    finally:
        # Rename the input file back to its original suffix if it was changed
        if old_suffix is not None:
            input_file.rename(input_file.with_suffix(old_suffix))


def build_shortcut(
        color: Optional[Literal['red', 'orange', 'tangerine', 'yellow', 'lime', 'teal', 'cyan', 'blue', 'navy', 'grape', 'purple', 'pink', 'gray', 'sage', 'khaki']] = None,
        glyph: Optional[str] = None,
        no_input_action: Optional[Literal['stopandrespond', 'ask', 'getclipboard', 'continue']] = None,
        ask_for_type: Optional[Literal['files', 'text', 'date', 'photos', 'contacts', 'email-address', 'music', 'phone-number']] = None,
        file_picker_mode: Optional[Literal['files', 'folders']] = 'files',
        photo_picker_modes: Optional[list[Literal['images', 'videos', 'live-photos', 'any']]] = None,
        date_picker_mode: Optional[str] = '',
        respond_message: Optional[str] = '',
        select_multiple: Optional[bool] = None,
        actions: Optional[list] = None,
        workflow_types: Optional[list[Literal["quick-action", "share-sheet", "menu-bar", "watch", "screen", "any"]]] = None,
        input_types: Optional[list[Literal["images", "media", "files", "folders", "pdfs", "text", "rich-text", "safari-web-pages", "urls", "articles", "maps-links", "locations", "contacts", "email-addresses", "phone-numbers", "dates", "app-store-apps", "itunes-products", "any"]]] = None
    ) -> dict:
    '''
    Construct an empty shortcut with configured defaults

    Used to create a new named shortcut with configured defaults for use in the 'create' subcommand
    '''

    base_shortcut = { 
        "WFQuickActionSurfaces": [], 
        "WFWorkflowActions": [], 
        "WFWorkflowClientVersion": "3607.0.2", 
        "WFWorkflowHasOutputFallback": False, 
        "WFWorkflowHasShortcutInputVariables": False, 
        "WFWorkflowIcon": { 
            "WFWorkflowIconGlyphNumber": 61440, # Default shortcut glyph
            "WFWorkflowIconStartColor": 3679049983 # Purple (hex #a062c9)
        }, 
        "WFWorkflowImportQuestions": [], 
        "WFWorkflowInputContentItemClasses": [], 
        "WFWorkflowMinimumClientVersion": 900, 
        "WFWorkflowMinimumClientVersionString": "900",
        "WFWorkflowOutputContentItemClasses": [], 
        "WFWorkflowTypes": [] 
    }

    workflow_types_map = {
        'quick-action': 'QuickActions',
        'share-sheet': 'ActionExtension',
        'menu-bar': 'MenuBar',
        'watch': 'Watch',
        'screen': 'ReceivesOnScreenContent'
    }

    input_types_map = {
        "images": "WFImageContentItem",
        "media": "WFAVAssetContentItem",
        "files": "WFGenericFileContentItem",
        "folders": "WFFolderContentItem",
        "pdfs": "WFPDFContentItem",
        "text": "WFStringContentItem",
        "rich-text":"WFRichTextContentItem",
        "safari-web-pages": "WFSafariWebPageContentItem",
        "urls": "WFURLContentItem",
        "articles": "WFArticleContentItem",
        "maps-links": "WFDCMapsLinkContentItem",
        "locations": "WFLocationContentItem",
        "contacts": "WFContactContentItem",
        "email-addresses": "WFEmailAddressContentItem",
        "phone-numbers": "WFPhoneNumberContentItem",
        "dates": "WFDateContentItem",
        "app-store-apps": "WFAppStoreAppContentItem",
        "itunes-products": "WFiTunesProductContentItem"
    }

    color_map = {
        'red': 4282601983,
        'orange': 4251333119,
        'tangerine': 4271458815,
        'yellow': 4274264319,
        'lime': 4292093695,
        'teal': 431817727,
        'cyan': 1440408063,
        'blue': 463140863,
        'navy': 946986751,
        'grape': 2071128575,
        'purple': 3679049983,
        'pink': 3980825855,
        'gray': 255,
        'sage': 3031607807,
        'khaki': 2846468607
    }
    
    ask_types_map = {
        'files': 'WFGenericFileContentItem',
        'text': 'WFStringContentItem',
        'date': 'WFDateContentItem',
        'photos': 'WFPhotoMediaContentItem',
        'contacts': 'WFContactContentItem',
        'email-address': 'WFEmailAddressContentItem',
        'music': 'WFMPMediaContentItem',
        'phone-number': 'WFPhoneNumberContentItem'
    }

    file_picker_map = {
        'files': 'Files',
        'folders': 'Folders'
    }

    photo_picker_map = {
        'images': 'Images',
        'videos': 'Videos',
        'live-photos': 'Live Photos'
    }

    if no_input_action:
        if no_input_action == 'stopandrespond':
            if not respond_message:
                respond_message = ''
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorShowError',
                'Parameters': {
                    'Error': respond_message
                }
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif no_input_action == 'getclipboard':
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorGetClipboard',
                'Parameters': {}
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif no_input_action == 'continue':
            pass
        else:
            print(f"\033[31mError\033[0m: Invalid default behavior '{no_input_action}'. Choose from {' ,'.join(['stopandrespond', 'getclipboard', 'continue'])}", file=sys.stderr)
            sys.exit(1)
    elif ask_for_type:
        if ask_for_type not in ask_types_map:
            print(f"\033[31mError\033[0m: Invalid 'Ask For' type '{ask_for_type}'. Choose from {' ,'.join(list(ask_types_map.keys()))}", file=sys.stderr)
            sys.exit(1)
        
        if ask_for_type == 'files':
            item_class = ask_types_map['files']
            parameters = {
                'ItemClass': item_class,
                'SerializedParameters': {
                    'WFPickingMode': file_picker_map[file_picker_mode],
                    'SelectMultiple': select_multiple,
                }
            }
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorAskForInput',
                'Parameters': parameters
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif ask_for_type == 'photos':
            item_class = ask_types_map['photos']
            if photo_picker_modes:
                if 'any' in photo_picker_modes:
                    photo_picker_modes = list(photo_picker_map.values())
                else:
                    photo_picker_modes = [photo_picker_map[photo_type] for photo_type in photo_picker_modes]
            parameters = {
                'ItemClass': item_class,
                'SerializedParameters': {
                    'WFPhotoPickerTypes': photo_picker_modes,
                    'WFSelectMultiplePhotos': select_multiple
                },
            }
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorAskForInput',
                'Parameters': parameters
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif ask_for_type == 'date':
            item_class = ask_types_map['date']
            if date_picker_mode == 'current':
                parameters = {
                    'ItemClass': item_class,
                    "SerializedParameters": {
                        "WFDateActionDate": 'Current Date',
                    }
                }
            else:
                parameters = {
                    'ItemClass': item_class,
                    "SerializedParameters": {
                        "WFDateActionDate": date_picker_mode,
                        "WFDateActionMode": "Specified Date"
                    }
                }
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorAskForInput',
                'Parameters': parameters
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif ask_for_type == 'contacts':
            item_class = ask_types_map['contacts']
            parameters = {
                'ItemClass': item_class,
                "SerializedParameters": {
                    "WFSelectMultiple": select_multiple
                }
            }
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorAskForInput',
                'Parameters': parameters
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        elif ask_for_type == 'music':
            item_class = ask_types_map['music']
            parameters = {
                "ItemClass": item_class,
                "SerializedParameters": {
                "WFExportSongActionSelectMultiple": select_multiple
                }
            }
            behavior = {
                'Name': 'WFWorkflowNoInputBehaviorAskForInput',
                'Parameters': parameters
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
        else:
            item_class = ask_types_map[ask_for_type]
            behavior = {
            "Name":"WFWorkflowNoInputBehaviorAskForInput",
            "Parameters": {
                "ItemClass": item_class
                }
            }
            base_shortcut['WFWorkflowNoInputBehavior'] = behavior
    if color:
        if color in color_map:
            base_shortcut['WFWorkflowIcon']['WFWorkflowIconStartColor'] = color_map[color]
        else:
            print(f"\033[33mWarning\033[0m: '{color}' is not a valid shortcut color. Using default color (purple)")
            base_shortcut['WFWorkflowIcon']['WFWorkflowIconStartColor'] = color_map['purple']

    if glyph:
        try:
            glyph_map = load_resource(filename='glyphs.json', data_type='json')
        except FileNotFoundError as e:
            print(e.args[0], file=sys.stderr)
            sys.exit(1)
        if glyph in glyph_map:
            base_shortcut['WFWorkflowIcon']['WFWorkflowIconGlyphNumber'] = glyph_map[glyph]
        else:
            print(f"\033[33mWarning\033[0m: '{glyph}' is not a valid glyph used by Shortcuts. Using default shortcut glyph")
            base_shortcut['WFWorkflowIcon']['WFWorkflowIconGlyphNumber'] = glyph_map['shortcuts']

    if workflow_types:
        if 'any' in workflow_types:
            selected_workflow_types = list(workflow_types_map.values())
        else:
            selected_workflow_types = [workflow_types_map.get(item) for item in workflow_types if item in workflow_types_map]
        base_shortcut['WFWorkflowTypes'] = selected_workflow_types

    if input_types:
        if 'any' in input_types:
            selected_input_types = list(input_types_map.values())
        else:
            selected_input_types = [input_types_map.get(item) for item in input_types if item in input_types_map]
        base_shortcut['WFWorkflowInputContentItemClasses'] = selected_input_types

    if actions:
        base_shortcut['WFWorkflowActions'] = actions

    return base_shortcut


def create_shortcut(
        name: Optional[str] = None,
        default_shortcut: Optional[dict] = None,
        save_destination: Optional[str] = None,
    ) -> None:
    '''
    Create a new shortcut in the Shortcuts Editor
    '''

    # Default behaviour when 'shortcut-util create' with no additional arguments
    if not name and not default_shortcut:
        try:
            url = 'shortcuts://create-shortcut'
            command = ['open', url]
            subprocess.run(
                command,
                check=True
            )
        except subprocess.CalledProcessError as e:
            print(f'Error: Unable to create new shortcut\n')
            print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
            print(e.stderr.decode('utf-8'), file=sys.stderr)
            sys.exit(e.returncode)

    # Behaviour for creating a named and configured shortcut
    if name:
        if save_destination:
            path = Path(save_destination).expanduser().resolve() / name
        else:
            path = Path('.').resolve() / name
        
        path = path.with_suffix('.wflow')

        with open(str(path), 'wb') as f:
            plistlib.dump(default_shortcut, f)

        sign_shortcut(
            input_path=str(path),
            output_path=str(path),
            signing_mode='anyone',
            add_to_library=False
        )

        try:
            import_shortcut(str(path))
            # This is to prevent a race condition where the file is deleted before it can be loaded by Shortcuts
            sleep(3)
        finally:
            # Delete the new shortcut after importing it into the Shortcuts library unless explicitly instructed to save it
            if not save_destination:
                path.unlink()
            

def export_shortcuts(
        save_dir: str,
        names: list[str],
        all: bool = False,
        compressed: bool = False,
        organize: bool = False,
        compression_algo: Optional[str] = None
    ) -> None:
    '''
    Export shortcuts from your library, optionally compressing and/or organizing them.

    Supported compression formats:
        - zip
        - tar.gz
        - tar.bz2
        - tar.xz
        - tar
        - gz
        - cpio
        - iso

    This function uses an external utility shortcut to export the shortcuts from your library.
    Please ensure you have added this shortcut to your library:

    Export Shortcuts Non-Interactive
    https://www.icloud.com/shortcuts/1e572591a5dd4d23850a0a6c2b289aa9
    '''

    utility_shortcut = 'Export Shortcuts Non-Interactive'

    supported_algos = ['zip', 'tar.gz', 'tar.bz2', 'tar.xz', 'tar', 'gz', 'cpio', 'iso']

    names = [name for name in names if shortcut_exists(name)]

    if not all and not names:
        print("Error: No shortcuts matching the names provided were found")
        sys.exit(1)

    if compressed and compression_algo not in supported_algos:
        print(f"\033[31mError\033[0m: '{compression_algo}' is not a supported compression algorithm")
        print(f"Supported Algorithms: {supported_algos}")
        sys.exit(1)

    save_path = Path(save_dir).resolve()
    save_path.mkdir(parents=True, exist_ok=True)

    options = {
        "names": names,
        "all": all,
        "compressed": compressed,
        "compression_algo": f".{compression_algo}"
    }

    try:
        command = ['shortcuts', 'run', utility_shortcut, '-i', '-']
        options_json = json.dumps(options)
        process = subprocess.run(
            command,
            input=options_json.encode('utf-8'),
            capture_output=True,
            check=True
        )
        encoded_data = process.stdout
    except subprocess.CalledProcessError as e:
        print("Error: Unable to export shortcuts\n")
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)

    zip_data = base64.b64decode(encoded_data)
    zip_buffer = BytesIO(zip_data)

    creation_date = datetime.now().strftime("%Y-%m-%d")

    if compressed:
        if organize:
            export_dir = save_path / "Shortcut Exports"
            export_dir.mkdir(parents=True, exist_ok=True)
        else:
            export_dir = save_path
        output_path = export_dir / f"Shortcuts export {creation_date}.{compression_algo}"
        output_path.write_bytes(zip_buffer.getvalue())
    else:
        with ZipFile(zip_buffer) as zip_file:
            if organize:
                for item in zip_file.namelist():
                    item_name = Path(item).stem
                    output_dir = save_path / item_name
                    output_dir.mkdir(parents=True, exist_ok=True)
                    zip_file.extract(item, path=output_dir)
            else:
                zip_file.extractall(path=save_path)


def colorize_diff(diff_lines: list[str]) -> str:
    '''
    Colorize the lines added in green and the lines removed in red in the diff generated by compare_shortcuts()
    '''
    
    RESET = '\033[0m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    colored_lines = []
    for line in diff_lines:
        if line.startswith('+') and not line.startswith('+++'):
            colored_lines.append(f"{GREEN}{line}{RESET}")
        elif line.startswith('-') and not line.startswith('---'):
            colored_lines.append(f"{RED}{line}{RESET}")
        else:
            colored_lines.append(line)
    return '\n'.join(colored_lines)


def compare_shortcuts(name1: str, name2: str) -> None:
    '''
    Generate a unified diff of two shortcuts
    '''

    for name in [name1, name2]:
        if not shortcut_exists(name):
            print(f"\033[31mError\033[0m: '{name}' does not appear to match the name of a shortcut in your library", file=sys.stderr)
            sys.exit(1)
    
    shortcut1 = get_shortcut_plist(name1, output_dict=False).splitlines(keepends=False)
    shortcut2 = get_shortcut_plist(name2, output_dict=False).splitlines(keepends=False)

    diff = list(difflib.unified_diff(
        shortcut1,shortcut2,
        fromfile=f'{name1}.shortcut',
        tofile=f'{name2}.shortcut',
        lineterm=''
    ))

    if diff:
        unified_diff = colorize_diff(diff)
        print(unified_diff)
    else:
        print("âœ… No differences detected")


def build_shortcuts_url(
        shortcut_name: Optional[str] = None,
        run: bool = True,
        open: bool = False,
        create: bool = False,
        import_link: bool = False,
        gallery: bool = False,
        automations: bool = False,
        input_type: str = 'text',
        text: Optional[str] = None,
        x_callback: bool = False,
        x_success_url: Optional[str] = None,
        x_cancel_url: Optional[str] = None,
        x_error_url: Optional[str] = None
        ) -> str:
    '''
    Construct a shortcuts URL for running, opening, importing, and creating shortcuts.

    The parameter 'input' can either be 'text' or 'clipboard'

    Note:
        Certain URL routes such as 'create', 'gallery', and 'automations' don't take any
        parameters and cannot be used to create new shortcuts with a pre-filled name fields
        nor can they be used navigate to specific automations or items Shortcuts gallery.

        Thus for these routes, the base URL will be output
    '''
    
    if create:
        return 'shortcuts://create-shortcut'
    
    if gallery:
        return 'shortcuts://gallery'
    
    if automations:
        return 'shortcuts://automations'
    
    if open:
        name = quote(shortcut_name, safe='')
        return f'shortcuts://open-shortcut?name={name}'
    
    if import_link:
        if not shortcut_exists(shortcut_name):
            print(f"\033[31mError\033[0m: Unable to build an import URL for a non-existent shortcut")
            sys.exit(1)
        else:
            icloud_url = get_icloud_url(shortcut_name)
            identifier = get_icloud_url_identifier(icloud_url)
            return f"shortcuts://shortcuts/{identifier}"
    
    if run:
        name = quote(shortcut_name, safe='')
        if not x_callback:
            # text input
            if input_type == 'text':
                input_text = quote(text, safe='')
                return f"shortcuts://run-shortcut?name={name}&input={input_type}&text={input_text}"
            # clipboard input
            elif input_type == 'clipboard':
                return f"shortcuts://run-shortcut?name={name}&input={input_type}"
            # invalid input type
            else:
                print(f"\033[31mError\033[0m: Invalid input type '{input_type}'\nAccepted input types: 'text', 'clipboard'")
                sys.exit(1)
        else:
            x_success = quote(x_success_url, safe='')
            x_cancel = quote(x_cancel_url, safe='')
            x_error = quote(x_error_url, safe='')

            # text input
            if input_type == 'text':
                input_text = quote(text, safe='')
                return f"shortcuts://x-callback-url/run-shortcut?name={name}&input={input_type}&text={input_text}&x-success={x_success}&x-cancel={x_cancel}&x-error={x_error}"
            # clipboard input
            elif input_type == 'clipboard':
                return f"shortcuts://x-callback-url/run-shortcut?name={name}&input={input_type}&x-success={x_success}&x-cancel={x_cancel}&x-error={x_error}"
            # invalid input type
            else:
                print(f"\033[31mError\033[0m: Invalid input type '{input_type}'\nAccepted input types: 'text', 'clipboard'")
                sys.exit(1)


def run_shortcut(
    shortcut_name: str,
    shortcut_input: Optional[str] = None,
    input_is_file: bool = False,
    shortcut_output: Optional[str] = None,
    output_uti: Optional[str] = None
) -> None:
    '''
    Run a shortcut, optionally providing input and/or specifying an output destination.

    Parameters:
    - shortcut_name: The name or UUID of a Shortcut.
    - shortcut_input: File path, '-' for stdin, or literal string input.
    - input_is_file: If True, treat shortcut_input as a file path.
    - shortcut_output: File path to write output, or '-' for stdout.
    - output_uti: Uniform Type Identifier (UTI) of output type.
    '''
    command = ['shortcuts', 'run', shortcut_name]

    process_input = None

    if shortcut_input:
        command.extend(['-i', '-'])

        if input_is_file:
            input_path = Path(shortcut_input).expanduser().resolve()
            if not input_path.exists():
                print(f"\033[31mError\033[0m: Input file '{input_path}' not found.", file=sys.stderr)
                sys.exit(1)
            process_input = input_path.read_bytes()
        elif shortcut_input == '-':
            process_input = sys.stdin.buffer.read()
        else:
            process_input = shortcut_input.encode('utf-8')

    if shortcut_output:
        if shortcut_output == '-':
            command.extend(['-o', '-'])
        else:
            output_path = Path(shortcut_output).expanduser().resolve()
            command.extend(['-o', str(output_path)])

        if output_uti:
            command.extend(['--output-type', output_uti])

    try:
        process = subprocess.run(
            command,
            input=process_input,
            capture_output=True,
            check=True
        )

        if shortcut_output == '-' or not shortcut_output:
            if process.stdout:
                sys.stdout.buffer.write(process.stdout)
                sys.stdout.buffer.flush()
        if process.stderr:
            print(process.stderr.decode('utf-8'), file=sys.stderr)

    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def is_valid_time_interval(interval: str) -> bool:
    '''
    Validate that the given time interval is in a valid format used by the log command

    Examples of valid intervals:
        - 10m  # 10 minutes
        - 4h   # 4 hours
        - 2d   # 2 days
    '''
    result = re.search(r'^[0-9]+[mhd]{1}$', interval)
    return True if result else False


def is_valid_timestamp(timestamp: str) -> bool:
    '''
    Validate that the given start or end time strings are in valid datetime formats used by the log command

    Valid formats:
        - YYYY-MM-DD
        - YYYY-MM-DD HH:MM:SS
        - YYYY-MM-DD HH:MM:SSZZZZZ
    '''
    result = re.search(r'\b\d{4}-\d{2}-\d{2}(?:[ ]\d{2}:\d{2}:\d{2}(?:[+-]\d{4})?)?\b', timestamp)
    return True if result else False


def is_valid_export_size(size: str) -> bool:
    '''
    Validate that the given export size string is in a valid format used by the log command

    Examples of valid sizes:
        - 100k  # 100 kilobytes
        - 20m   # 20 megabytes
    '''
    result = re.search(r'^[0-9]+[km]{1}$', size)
    return True if result else False


def is_valid_UDID(identifier: str) -> bool:
    '''
    Validate that the given device UDID is valid. Supports old and new style UDIDs
    '''
    result = re.search(r'\b(?:[a-f0-9]{40}|[0-9a-fA-F]{8}-[0-9a-fA-F]{16})\b', identifier)
    return True if result else False


def build_predicate(
    subsystem_category: Optional[str] = None,
    sender_image: Optional[str] = None,
    process_name: Optional[str] = None,
    include_events: Optional[list[Literal['info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction']]] = None
    ) -> str:
    '''
    Build a predicate for filtering shortcut logs
    '''
    base_predicate = 'subsystem == "com.apple.shortcuts"'

    if subsystem_category:
        base_predicate += f' AND category == "{subsystem_category}"'

    if sender_image:
        base_predicate += f' AND sender == "{sender_image}"'
    
    if process_name:
        base_predicate += f' AND process == "{process_name}"'

    event_type_filters = {
        'activity': 'eventType == activityCreateEvent',
        'transition': 'eventType == activityTransitionEvent',
        'state': 'eventType == stateEvent',
        'timesync': 'eventType == timesyncEvent',
        'userAction': 'eventType == userActionEvent',
        'signpost': 'eventType == signpostEvent',
        'loss': 'eventType == lossEvent',
        'trace': 'eventType == traceEvent'
    }

    message_type_filters = {
        'info': 'messageType == info',
        'default': 'messageType == default',
        'debug': 'messageType == debug',
        'error': 'messageType == error',
        'fault': 'messageType == fault'
    }

    event_filters_selected = []
    message_filters_selected = []

    if include_events:
        for event in include_events:
            if event in event_type_filters:
                event_filters_selected.append(event_type_filters[event])
            elif event in message_type_filters:
                message_filters_selected.append(message_type_filters[event])

    combined_filters = []

    if event_filters_selected:
        combined_filters.append('(' + ' OR '.join(event_filters_selected) + ')')

    if message_filters_selected:
        combined_filters.append('(' + ' OR '.join(message_filters_selected) + ')')

    if combined_filters:
        predicate = f"{base_predicate} AND {' AND '.join(combined_filters)}"
    else:
        predicate = base_predicate

    return predicate


def process_with_environment(command: list[str], environment: dict) -> None:
    '''
    Spawn a process in a pseudo-terminal environment.
    Used to show colored output in the 'logs' subcommand.
    '''
    pid, file_descriptor = pty.fork()
    if pid == 0:
        os.execvpe(command[0], command, environment)
    else:
        try:
            while True:
                output = os.read(file_descriptor, 1024)
                if not output:
                    break
                sys.stdout.buffer.write(output)
                sys.stdout.buffer.flush()
        except OSError:
            pass


def export_shortcut_logs(
    predicate: str,
    output_path: str,
    time_interval: Optional[str] = None,
    start: Optional[str] = None,
    end: Optional[str] = None,
    log_size: Optional[str] = None,
    from_first_paired_device: bool = False,
    device_name: Optional[str] = None,
    device_udid: Optional[str] = None,
    ) -> None:
    '''
    Export shortcut logs from this device or a paired device to a new logarchive, optionally filtering the logs
    '''

    command = ['log', 'collect', '--predicate', predicate]

    save_path = Path(output_path).expanduser().resolve()

    if save_path.suffix:
        if save_path.suffix != '.logarchive':
            print(f"\033[31mError\033[0m: Invalid export path '{str(output_path)}'")
            print("Output path must either be a directory or have the suffix .logarchive")
            sys.exit(1)
        else:
            command.extend(['--output', str(save_path)])
    else:
        save_path.mkdir(parents=True, exist_ok=True)
        filename = f"Shortcuts logs {datetime.now().strftime("%Y-%m-%d")}.logarchive"
        save_path = save_path / filename 
        command.extend(['--output', str(save_path)])

    if time_interval:
        if not is_valid_time_interval(time_interval):
            print(f"\033[33mWarning\033[0m: Invalid time interval '{time_interval}'. Ignoring ...")
        else:
            command.extend(['--last', time_interval])

    if start:
        if not is_valid_timestamp(start):
            print(f"\033[33mWarning\033[0m: Invalid timestamp '{start}'. Ignoring ...")
        else:
            command.extend(['--start', start])

        if end:
            if not is_valid_timestamp(end):
                print(f"\033[33mWarning\033[0m: Invalid timestamp '{end}'. Ignoring ...")
            else:
                command.extend(['--end', end])

    if log_size:
        if not is_valid_export_size(log_size):
            # Exit if a log size is provided but is invalid
            print(f"\033[31mError\033[0m: Invalid export size '{log_size}'")
            sys.exit(1)
        else:
            command.extend(['--size', log_size])
    
    if from_first_paired_device:
        command.extend(['--device'])
    
    if device_name:
        command.extend(['--device-name', device_name])
    
    if device_udid:
        if is_valid_UDID(device_udid):
            command.extend(['--device-udid', device_udid])
        else:
            # Exit if a UDID is provided but is invalid
            print(f"\033[31mError\033[0m: Invalid UDID '{device_udid}'")
            sys.exit(1)
    
    try:
        print("Creating a new logarchive ... This could take a long time")
        subprocess.run(
            command,
            check=True,
            stderr=subprocess.DEVNULL
        )
    except subprocess.CalledProcessError as e:
        print(f"Command '{' '.join(command)}' failed with error code {e.returncode}", file=sys.stderr)
        print(e.stderr.decode('utf-8'), file=sys.stderr)
        sys.exit(e.returncode)


def stream_shortcut_logs(
    predicate: str,
    show_color: bool = True,
    process: Optional[str] = None,
    log_format: Literal['default', 'compact', 'json', 'syslog'] = 'default',
    timeout: Optional[str] = None,
    include_source: bool = False,
    ) -> None:
    '''
    Stream events from the Shortcuts subsystem log, optionally filtering the formatting the output
     
    Optional filters:
        - process (either a process name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)
        - subsystem category (e.g, "General", "Database", "Dialog", "Editor", "Workflow", "WorkflowExecution", "XPCEvent", ...) # NOTE: As well as many other options not listed here
        - sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)
        - events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')
        - include source symbols and line numbers when available

    Output formatting:
        - colored output
        - log format (e.g, "default", "compact", "json", "syslog")
    '''

    log_formats = ['default', 'compact', 'json', 'syslog']
    
    colorable_formats = ['default', 'compact']

    command = ['log', 'stream', '--predicate', predicate]
    
    if process is not None:
        command.extend(['--process', process])

    if include_source:
        command.extend(['--source'])

    if log_format and log_format in log_formats:
        command.extend(['--style', log_format])
    else:
        command.extend(['--style', 'default'])
    
    if show_color:
        if log_format not in colorable_formats:
            command.extend(['--color', 'none'])
        command.extend(['--color', 'always'])

    if timeout:
        if not is_valid_time_interval(timeout):
            # Exit if a timeout was provided but was invalid so the process dosen't run in the background forever
            print(f"\033[31mError\033[0m: Invalid timeout interval '{timeout}'.")
            sys.exit(1)
        else:
            command.extend(['--timeout', timeout])
    
    try:
        env = os.environ.copy()
        env.update({
        'TERM': 'xterm-256color',
        'CLICOLOR_FORCE': '1',
        'CLICOLOR': '1'
        })
        print("Streaming logs... Press Ctrl+C to stop.\n")
        process_with_environment(command, environment=env)
    except KeyboardInterrupt:
        # The user manually stopped the stream with Ctrl+C
        print('\nStopping stream ...')
        sys.exit()
    except Exception as e:
        print(f"Error while running command: '{command}'")
        print(e)
        sys.exit(1)


def view_shortcuts_logs(
    predicate: str,
    show_color: bool = True,
    from_archive: Optional[str] = None,
    time_interval: Optional[str] = None,
    start: Optional[str] = None,
    end: Optional[str] = None,
    process: Optional[str] = None,
    include_source: bool = False,
    log_format: Literal['default', 'compact', 'json', 'ndjson', 'syslog'] = 'default',
) -> None:
    '''
    View events from the Shortcuts subsystem log, optionally filtering and formatting the output
     
    Optional filters:
        - time interval (e.g, "5m", "3h", "1d", or "boot" for minutes, hours, days, and since last reboot respectively)
        - start date/time (acceptable formats "YYYY-MM-DD", "YYYY-MM-DD HH:MM:SS", "YYYY-MM-DD HH:MM:SSZZZZZ")
        - end date/time (acceptable formats "YYYY-MM-DD", "YYYY-MM-DD HH:MM:SS", "YYYY-MM-DD HH:MM:SSZZZZZ")
        - process (either a process name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)
        - sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)
        - subsystem category (e.g, "General", "Database", "Dialog", "Editor", "Workflow", "WorkflowExecution", "XPCEvent", ...) # NOTE: As well as many other options not listed here
        - events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')
        - include source symbols and line numbers when available

    Optional output formatting:
        - colored output
        - log format (e.g, "default", "compact", "json", "ndjson", "syslog")
    '''

    log_formats = ['default', 'compact', 'json', 'ndjson', 'syslog']

    colorable_formats = ['default', 'compact']

    command = ['log', 'show', '--predicate', predicate]

    if process is not None:
        command.extend(['--process', process])

    if include_source:
        command.extend(['--source'])

    if log_format and log_format in log_formats:
        command.extend(['--style', log_format])
    else:
        command.extend(['--style', 'default'])
    
    if show_color:
        if log_format not in colorable_formats:
            command.extend(['--color', 'none'])
        command.extend(['--color', 'always'])
    
    if time_interval:
        if not is_valid_time_interval(time_interval) and not time_interval == 'boot':
            print(f"\033[33mWarning\033[0m: Invalid time interval '{time_interval}'. Ignoring ...")
        else:
            command.extend(['--last', time_interval])
    
    if start:
        if not is_valid_timestamp(start):
            print(f"\033[33mWarning\033[0m: Invalid timestamp '{start}'. Ignoring ...")
        else:
            command.extend(['--start', start])

        if end:
            if not is_valid_timestamp(end):
                print(f"\033[33mWarning\033[0m: Invalid timestamp '{end}'. Ignoring ...")
            else:
                command.extend(['--end', end])

    if from_archive:
        archive_path = Path(from_archive).resolve()
        if not archive_path.exists() or not archive_path.suffix == '.logarchive':
            # Exit here since the user explicitly wants to view logs from a logarchive and the path is invalid
            print(f"\033[31mError\033[0m: Invalid logarchive path '{str(archive_path)}'")
            sys.exit(1)
        command.extend(['--archive', str(archive_path)])
    
    try:
        env = os.environ.copy()
        env.update({
        'TERM': 'xterm-256color',
        'CLICOLOR_FORCE': '1',
        'CLICOLOR': '1'
        })
        process_with_environment(command, environment=env)
    except Exception as e:
        print(f"Error running command: '{command}'")
        print(e)
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        prog='shortcut-util',
        description="Apple Shortcuts Utility",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "\033[37mExamples:\033[0m\n"
            "  shortcut-util run -n 'My Shortcut' -i 'Some Data'\n"
            "  cat MyFile.txt | shortcut-util run -n 'My Shortcut' -i - -o -\n"
            "  shortcut-util run -n 'My Shortcut' -i 'MyFile.json' -o 'MyResult.plist' --output-uti 'com.apple.property-list'\n"
            "  shortcut-util get-actions <shortcut-name>\n"
            "  shortcut-util count-actions <shortcut-name>\n"
            "  shortcut-util convert <shortcut-name> --json\n"
            "  shortcut-util convert <shortcut-name> --plist\n"
            "  shortcut-util convert <shortcut-name> --plist -s <save-destination> --file-extension shortcut\n"
            "  shortcut-util convert <shortcut-name> --plist --save-dir <save-destination> -f wflow\n"
            "  shortcut-util get-uuid <shortcut-name>\n"
            "  shortcut-util open <shortcut-name>\n"
            "  shortcut-util import <path-to-shortcut-file>\n"
            "  shortcut-util import <shortcut-share-url> --url\n"
            "  shortcut-util create\n"
            "  shortcut-util create -n <new-shortcut-name> -i images media -t share-sheet -c red -g photoStack --ask photos --photo-modes any --multiple\n"
            "  shortcut-util create --name <new-shortcut-name> --input-types locations --workflow-types share-sheet --color lime --glyph locationArrow --no-input-behavior getclipboard \n"
            "  shortcut-util icloud-url <shortcut-name>\n"
            "  shortcut-util export -n <shortcut-name> -s <save-destination>\n"
            "  shortcut-util export --names <shortcut1> <shortcut2> --save-dir <save-destination> --organize\n"
            "  shortcut-util export --all -s <save-destination> --compressed -algo tar.gz\n"
            "  shortcut-util diff <shortcut1> <shortcut2>\n"
            "  shortcut-util build-url --run --name <shortcut-name> --type text --text 'This is some example input text'\n"
            "  shortcut-util build-url --open --name <shortcut-name>\n"
            "  shortcut-util build-url --run --name <shortcut-name> --type clipboard --x-callback --success <x-success-url> --cancel <x-cancel-url> --error <x-error-url>\n"
            "  shortcut-util build-url --import-link --name <shortcut-name>\n"
            "  shortcut-util build-url --automations\n"
            "  shortcut-util build-url --gallery\n"
            "  shortcut-util build-url --create\n"
            "  shortcut-util sign -i <input-plist-path> -m people-who-know-me -o <output-shortcut-path>\n"
            "  shortcut-util sign --input <input-plist-path> --signing-mode anyone --output <output-shortcut-path> --add-to-library\n"
            "  shortcut-util logs view --last 10h\n"
            "  shortcut-util logs view --last 10h --process BackgroundShortcutRunner --sender WorkflowKit --category Workflow --format json\n"
            "  shortcut-util logs stream --timeout 5m\n"
            "  shortcut-util logs stream --timeout 2m --format compact --include info debug error fault userAction\n"
            "  shortcut-util logs export --last 24h --output ~/Shortcut Logs.logarchive\n"
            '  shortcut-util logs export --last 24h --process Shortcuts --device-name "Bob\'s iPhone" --output ~/Shortcut Logs.logarchive\n'
        )
    )
    subparsers = parser.add_subparsers(dest='command', required=True, help='\033[37mSubcommands\033[0m')

    # get-actions parser
    get_actions_parser = subparsers.add_parser('get-actions', help='Extract the actions from a Shortcut')
    get_actions_parser.add_argument('name', help='The name of the Shortcut to parse')
    get_actions_parser.add_argument('-j', '--json', action='store_true', help='Output actions in JSON format')
    get_actions_parser.add_argument('-i', '--identifiers', action='store_true', help='Output a list of shortcut action identifiers present in the shortcut')

    # count-actions parser
    count_actions_parser = subparsers.add_parser('count-actions', help='Count the actions in a Shortcut')
    count_actions_parser.add_argument('name', help='The name of the Shortcut')

    # convert parser
    convert_parser = subparsers.add_parser('convert', help="Convert a Shortcut to JSON or PLIST")
    convert_parser.add_argument('name', help="The name of the Shortcut to convert")
    convert_parser.add_argument('-j','--json', action='store_true', help="Convert the Shortcut to JSON")
    convert_parser.add_argument('-p','--plist', action='store_true', help="Convert the Shortcut to PLIST")
    convert_parser.add_argument('-s', '--save-dir', type=str, help='The directory to save the converted shortcut to')
    convert_parser.add_argument('-f', '--file-extension', type=str, help=(
        "The extension to associate with the saved file."
        "This can either be 'wflow', 'shortcut', 'plist', or 'json'."
        "Note: Only files with the extensions '.wflow' '.shortcut' can be signed"
    ))

    # get-uuid parser
    get_uuid_parser = subparsers.add_parser('get-uuid', help="Get the UUID of a Shortcut")
    get_uuid_parser.add_argument('name', help="The name of the Shortcut to retrieve the UUID of")

    # open parser
    open_parser = subparsers.add_parser('open', help='Open a shortcut in the Shortcuts Editor')
    open_parser.add_argument('name', help='The name of the Shortcut to open')

    # import parser
    import_parser = subparsers.add_parser('import', help="Import a shortcut from a file or icloud share url into your Shortcuts Library")
    import_parser.add_argument('path_or_url', help='The path to the shortcut file or the iCloud Share URL of the shortcut to import')
    import_parser.add_argument('--url', action='store_true', help='Import the shortcut from an iCloud Share URL')

    # create parser
    create_parser = subparsers.add_parser('create', help='Create a new shortcut, optionally naming and configuring it')
    create_parser.add_argument('-n', '--name', type=str, help="Create a new shortcut with the given name")
    create_parser.add_argument('-i', '--input-types', type=str, nargs='+', help=(
        'The input item content types to accept in the new shortcut'
        '(e,g."images", "media", "files", "folders", "pdfs",'
        '"text", "rich-text", "safari-web-pages", "urls", "articles",'
        '"maps-links", "locations", "contacts", "email-addresses", "phone-numbers",'
        '"dates", "app-store-apps", "itunes-products", "all")'
    ))
    create_parser.add_argument('-t', '--workflow-types', type=str, nargs='+', help=(
        'The workflow types to allow in the new shortcut'
        '(e,g. "quick-action", "share-sheet", "menu-bar", "watch", "screen", "any")'
    ))
    create_parser.add_argument('-s', '--save-destination', type=str, help=(
        "The directory to save the new shortcut to."
        "By default the newly created shortcut will delete the shortcut file after importing it unless specified not to"
    ))
    create_parser.add_argument('-c', '--color', type=str, help=(
        "Set the color of the new shortcut"
        "(e.g, 'red', 'orange', 'tangerine', 'yellow', 'lime', 'teal', 'cyan', 'blue', 'navy', 'grape', 'purple', 'pink', 'gray', 'sage', 'khaki')"
    ))
    create_parser.add_argument('-g', '--glyph', type=str, help="The name of the glyph to use in the new shortcut's icon")
    create_parser.add_argument('--multiple', action='store_true', help="Allow selecting multiple items when '--ask files' or '--ask files' is specified")
    create_parser.add_argument(
        '--file-mode',
        type=str,
        choices=['files', 'folders'],
        default='files',
        help="Picking mode when '--ask files' is specified. Can be either 'files' or 'folders' (default: 'files')"
    )
    create_parser.add_argument(
        '--photo-modes',
        type=str,
        nargs='+',
        choices=['images', 'videos', 'live-photos', 'any'],
        default=['images', 'videos', 'live-photos'],
        help="Specify photo picker types when '--ask photos' is used (default: all)"
    )
    create_parser.add_argument(
        '--date-mode',
        type=str,
        default='current',
        help="Specify whether to use the current date or a specific date when '--ask date' is specified (default: 'current')"
    )
    create_parser.add_argument('--response', type=str, help="The message to fill in the 'Stop and Respond' field")
    create_parser.add_argument(
        '--template',
        type=str,
        help=(
            "The name of the action template to load\n"
            ""
            "For example, to load the template from <PROJECT_DIR>/resources/shortcut-util/action_templates/input-handler.py, provide 'input-handler' as the argument"
        )
    )
    
    # create parser arguments that can't be included in the same command
    no_input_group = create_parser.add_mutually_exclusive_group()
    no_input_group.add_argument(
        '-D', '--no-input-behavior',
        type=str,
        choices=['stopandrespond', 'getclipboard', 'continue'],
        help="The default action to perform when a shortcut is run without input"
    )
    no_input_group.add_argument(
        '--ask',
        choices=['files', 'text', 'date', 'photos', 'contacts', 'email-address', 'music', 'phone-number'],
        help="Configures the shortcut to prompt the user for input of a specific type"
    )

    # icloud-url parser
    icloud_url_parser = subparsers.add_parser('icloud-url', help='Create an iCloud Share URL for a shortcut in your library')
    icloud_url_parser.add_argument('name', help='The name of the shortcut to create the iCloud Share URL for')

    # export parser
    export_parser = subparsers.add_parser('export', help="Export shortcuts from your library, optionally compressing and/or organizing them into folders")
    export_parser.add_argument('-n', '--names', nargs='+', type=str, default=[], help='The name(s) of the shortcuts to export')
    export_parser.add_argument('-a', '--all', action='store_true', help="Export all shortcuts in your library")
    export_parser.add_argument('-c','--compressed', action='store_true', help="Whether or not to compress the exported shortcuts")
    export_parser.add_argument('-algo', '--compression-algorithim', type=str, default='zip', help="The compression algorithim to use: (zip, tar.gz, tar.bz2, tar.xz, tar, gz, cpio, iso)")
    export_parser.add_argument('-o', '--organize', action='store_true', help="Whether or not to organize the exported shortcuts into folders")
    export_parser.add_argument('-s', '--save-dir', type=str, default='.', help="The directory to save the exported shortcuts to")

    # diff parser
    diff_parser = subparsers.add_parser('diff', help="Generate a unified diff of two shortcuts for comparison")
    diff_parser.add_argument('name1', type=str, help='The first shortcut to compare')
    diff_parser.add_argument('name2', type=str, help='The second shortcut to compare')

    # build-url parser
    build_url_parser = subparsers.add_parser('build-url', help="Construct a shortcuts URL for running, opening, and creating shortcuts")
    build_url_parser.add_argument('-n', '--name', type=str, help='The name of the shortcut to build the run/open URL for')
    build_url_parser.add_argument('-r', '--run', action='store_true', help="Build a URL for running shortcuts")
    build_url_parser.add_argument('-o', '--open', action='store_true', help="Build a URL for opening shortcuts")
    build_url_parser.add_argument('-c', '--create', action='store_true', help="Build a URL for opening a new shortcut in the Shortcut Editor")
    build_url_parser.add_argument('-I', '--import-link', action='store_true', help="Build a URL for importing shortcuts into your Shortcuts Library")
    build_url_parser.add_argument('-g','--gallery', action='store_true', help="Build a URL to open the Shortcuts Gallery")
    build_url_parser.add_argument('-a', '--automations', action='store_true', help="Build a URL for opening the Automations tab in the Shortcuts app")
    build_url_parser.add_argument('-t', '--type', type=str, help="The type of shortcut input. This can be either 'text' or 'clipboard'")
    build_url_parser.add_argument('-T', '--text', type=str, help="The text to use as input to the shortcut")
    build_url_parser.add_argument('-x', '--x-callback', action='store_true', help='Build an X-Callback-URL')
    build_url_parser.add_argument('--success', type=str, help="The URL to open if the shortcut runs successfully")
    build_url_parser.add_argument('--cancel', type=str, help="The URL to open if the shortcut run was cancelled")
    build_url_parser.add_argument('--error', type=str, help="The URL to open if an error occurs while the shortcut is running")

    # sign parser
    sign_parser = subparsers.add_parser('sign', help="Sign a shortcut plist file and output a signed shortcut")
    sign_parser.add_argument('-i', '--input', type=str, help='The path to the shortcut plist file. Acceptable file-extensions: (.shortcut, .wflow, .plist)')
    sign_parser.add_argument('-m', '--signing-mode',type=str, default='anyone', help='Whether to sign the shortcut for anyone to use, or for personal use (only you and people who have you in their contacts will be able to use it)')
    sign_parser.add_argument('-o', '--output', type=str, help='The path to save the signed shortcut to')
    sign_parser.add_argument('-L', '--add-to-library', action='store_true', help='Whether to import the signed shortcut to your Shortcuts Library after processing')

    # run parser
    run_parser = subparsers.add_parser('run', help="Run a Shortcut in your library")
    run_parser.add_argument('-n', '--name', type=str, help="The name or UUID of the shortcut to run")
    run_parser.add_argument('-i', '--input', type=str, help="The input to provide to the shortcut. Use '-' to read from stdin")
    run_parser.add_argument('--file', action='store_true', help="Treat the input argument as a file")
    run_parser.add_argument('-o', '--output', type=str, help="The output destination. Can either be a file path or '-' to write the output to stdout")
    run_parser.add_argument('--output-uti', type=str, help="The Uniform Type Identifier to output the data in")

    # logs parser
    logs_parser = subparsers.add_parser('logs', help="View, stream or export Shortcuts logs")
    logs_subparsers = logs_parser.add_subparsers(dest='logs_command', required=True)

    # view logs subparser
    view_parser = logs_subparsers.add_parser('view', help="View Shortcuts logs, optionally filtering them")
    view_parser.add_argument('--color', action='store_true', help="Show colored output")
    view_parser.add_argument('--from-archive', type=str, help="View matching logs in a logarchive")
    view_parser.add_argument('--last', type=str, help="View log events from the given time interval. (e.g, 20m, 4h, 2d, boot for minutes, hours, days and the time since last reboot respectively)")
    view_parser.add_argument('--start', type=str, help="View events from the given start date on (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    view_parser.add_argument('--end', type=str, help="View events until the given end date. Requires --start (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    view_parser.add_argument('--process', type=str, help='View log events created by a specific process (process-name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)')
    view_parser.add_argument('--format', type=str, help='log format (e.g, "default", "compact", "json", "ndjson", "syslog")')
    view_parser.add_argument('--source', action='store_true', help="Include line numbers and symbols when available")
    view_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    view_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    view_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    # stream logs subparser
    stream_parser = logs_subparsers.add_parser('stream', help="Stream Shortcuts logs, optionally filtering them")
    stream_parser.add_argument('--color', action='store_true', help="Show colored output")
    stream_parser.add_argument('--process', type=str, help='Include only log events created by a specific process (process-name or PID) (e.g, "Shortcuts", "BackgroundShortcutRunner", "Shortcut Events", ...)')
    stream_parser.add_argument('--format', type=str, help='log format (e.g, "default", "compact", "json", "syslog")')
    stream_parser.add_argument('--timeout', type=str, help="Exit after the given time interval has elapsed (e.g, 20m, 4h, 2d, boot for minutes, hours, and days respectively)")
    stream_parser.add_argument('--source', action='store_true', help="Include line numbers and symbols when available")
    stream_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    stream_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    stream_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    # export logs parser
    export_logs_parser = logs_subparsers.add_parser('export', help='Export Shortcut logs to a logarchive, optionally filtering them')
    export_logs_parser.add_argument('-o', '--output', type=str, help="The path to save the created logarchive to")
    export_logs_parser.add_argument('--last', type=str, help="Include log events from the given time interval. (e.g, 20m, 4h, 2d for minutes, hours, and days respectively)")
    export_logs_parser.add_argument('--start', type=str, help="Include events from the given start date on (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")    
    export_logs_parser.add_argument('--end', type=str, help="Include events until the given end date. Requires --start (acceptable formats YYYY-MM-DD, YYYY-MM-DD HH:MM:SS, YYYY-MM-DD HH:MM:SSZZZZZ)")
    export_logs_parser.add_argument('--size', type=str, help="The size to the limit the logarchive to (acceptable formats: 100k, 20m for kilobytes and megabytes respectively)")
    export_logs_parser.add_argument('--first-device', action='store_true', help="Export logs from the first paired device found")
    export_logs_parser.add_argument('--device-name', type=str, help="Export logs from a paired device with the given name")
    export_logs_parser.add_argument('--UDID', type=str, help="Export logs from a paired device with the given UDID")
    export_logs_parser.add_argument('--include', type=str, nargs='+', help="Include events and log levels (e.g, 'info', 'debug', 'error', 'fault', 'signpost', 'loss', 'trace', 'activity', 'transition', 'state', 'timesync', 'userAction')")
    export_logs_parser.add_argument('--process', type=str, help="Include log events created by a specific process (process name only)")
    export_logs_parser.add_argument('--category', type=str, help="The Shortcuts subsystem category (for example, 'General', 'Database', 'Dialog', 'Editor', 'Workflow', 'WorkflowExecution', 'XPCEvent', ...) As well as many other options not listed here")
    export_logs_parser.add_argument('--sender', type=str, help='The sender image name (e.g, "WorkflowKit", "VoiceShortcuts", "ContentKit", ...)')

    args = parser.parse_args()

    # get-actions main
    if args.command == 'get-actions':
        if not shortcut_exists(args.name):
            print(f"\033[31mError\033[0m: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)
        actions = get_shortcut_actions(plist)
        if args.identifiers:
            output = get_action_ids(actions)
        else:
            output = actions
            
        if args.json:
            print(json.dumps(output, indent=4))
        else:
            print(plistlib.dumps(output, fmt=plistlib.FMT_XML).decode('utf-8'))

    # count-actions main
    elif args.command == 'count-actions':
        if not shortcut_exists(args.name):
            print(f"\033[31mError\033[0m: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)
        actions = get_shortcut_actions(plist)
        print(len(actions))

    # convert main
    elif args.command == 'convert':
        if not shortcut_exists(args.name):
            print(f"\033[31mError\033[0m: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        plist = get_shortcut_plist(args.name)

        if args.json:
            if args.save_dir:
                save_shortcut(
                    shortcut_data=plist,
                    shortcut_name=args.name,
                    save_destination=args.save_dir,
                    extension='json',
                    isPlist=False
                )
            else:
                print(json.dumps(plist, indent=4))

        elif args.plist:
            if args.save_dir:
                if not args.file_extension:
                    ext = 'plist'
                else:
                    ext = args.file_extension  
                save_shortcut(
                    shortcut_data=plist,
                    shortcut_name=args.name,
                    save_destination=args.save_dir,
                    extension=ext,
                    isPlist=True
                )
            else:
                print(plistlib.dumps(plist, fmt=plistlib.FMT_XML).decode('utf-8'))

    # get-uuid main
    elif args.command == 'get-uuid':
        if not shortcut_exists(args.name):
            print(f"\033[31mError\033[0m: '{args.name}' does not exist in your Shortcuts library")
            sys.exit(1)

        uuid = get_shortcut_uuid(args.name)
        if not uuid:
            print(f"\033[31mError\033[0m: UUID for '{args.name}' not found")
            sys.exit(1)
        print(uuid)
    
    # open main
    elif args.command == 'open':
        open_shortcut(args.name)

    # import main
    elif args.command == 'import':
        if args.url:
            import_shortcut(args.path_or_url, isURL=True)
        else:
            import_shortcut(args.path_or_url)
    
    # create main
    elif args.command == 'create':
        # Default when creating a new shortcut unconfigured and with no name
        if not args.name:
            create_shortcut()
        
        if args.template:
            try:
                template_path = Path(args.template).with_suffix('.py')
                template = load_resource(filename=template_path.name, data_type='python', subdirectories=['action_templates'])
            except FileNotFoundError as e:
                print(e.args[0], file=sys.stderr)
                sys.exit(1)
        else:
            template = args.template

        shortcut = build_shortcut(
            color=args.color,
            glyph=args.glyph,
            no_input_action=args.no_input_behavior,
            ask_for_type=args.ask,
            file_picker_mode=args.file_mode,
            photo_picker_modes=args.photo_modes,
            date_picker_mode=args.date_mode,
            select_multiple=args.multiple,
            respond_message=args.response,
            actions=template,
            input_types=args.input_types,
            workflow_types=args.workflow_types
        )
        create_shortcut(
            name=args.name,
            default_shortcut=shortcut,
            save_destination=args.save_destination
        )

    # icloud-url main
    elif args.command == 'icloud-url':
        url = get_icloud_url(args.name)
        print(url)
    
    # export main
    elif args.command == 'export':
        export_shortcuts(
            save_dir=args.save_dir,
            names=args.names,
            all=args.all,
            compressed=args.compressed,
            organize=args.organize,
            compression_algo=args.compression_algorithim
        )

    # diff main
    elif args.command == 'diff':
        compare_shortcuts(args.name1, args.name2)

    # build-url main
    elif args.command == 'build-url':
        url = build_shortcuts_url(
            shortcut_name=args.name,
            run=args.run,
            open=args.open,
            create=args.create,
            import_link=args.import_link,
            gallery=args.gallery,
            automations=args.automations,
            input_type=args.type,
            text=args.text,
            x_callback=args.x_callback,
            x_success_url=args.success,
            x_cancel_url=args.cancel,
            x_error_url=args.error
        )
        print(url)

    # sign main
    elif args.command == 'sign':
        valid_modes = ['anyone','people-who-know-me']
        if args.signing_mode not in valid_modes:
            print(f"\033[31mError\033[0m: Invalid signing mode '{args.signing_mode}'.\nAcceptable signing modes: {valid_modes}")
            sys.exit(1)

        if args.add_to_library:
            add_to_library = True
        else:
            add_to_library = False
        
        sign_shortcut(
            input_path=args.input,
            output_path=args.output,
            signing_mode=args.signing_mode,
            add_to_library=add_to_library
        )
    
    # run main
    elif args.command == 'run':
        run_shortcut(
            shortcut_name=args.name,
            shortcut_input=args.input,
            input_is_file=args.file,
            shortcut_output=args.output,
            output_uti=args.output_uti
        )

    # logs main
    elif args.command == 'logs':
        predicate = build_predicate(
            subsystem_category=args.category,
            process_name=args.process,
            sender_image=args.sender,
            include_events=args.include
        )
        if args.logs_command == "view":
            view_shortcuts_logs(
                predicate,
                show_color=args.color,
                from_archive=args.from_archive,
                time_interval=args.last,
                start=args.start,
                end=args.end,
                process=args.process,
                include_source=args.source,
                log_format=args.format
            )
        elif args.logs_command == "stream":
            stream_shortcut_logs(
                predicate,
                show_color=args.color,
                process=args.process,
                log_format=args.format,
                timeout=args.timeout,
                include_source=args.source
            )
        elif args.logs_command == "export":
            export_shortcut_logs(
                predicate,
                output_path=args.output,
                time_interval=args.last,
                start=args.start,
                end=args.end,
                log_size=args.size,
                from_first_paired_device=args.first_device,
                device_name=args.device_name,
                device_udid=args.UDID
            )



if __name__ == "__main__":
    main()